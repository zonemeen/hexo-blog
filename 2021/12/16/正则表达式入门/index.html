

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="一位前端工程师的文章分享，主要发布 前端 / JavaScript / Node.js / Vue / React 等编程技术类文章。">
  <meta name="author" content="miqilin21">
  <meta name="keywords" content="前端、前端学习、前端编程、程序员、编程、博客、技术、转行、HTML、CSS、JavaScript、vue、react、Node.js、分享、blog、米淇淋、灵谦、miqilin、生活、爱好">
  <title>JS正则表达式入门 - 灵谦的个人博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_2565223_esykp744a67.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"me.miqilin21.cn","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"#"},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="灵谦的个人博客" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav
  id="navbar"
  class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"
>
  <div class="container">
    <a class="navbar-brand" href="/"
      >&nbsp;<strong>灵谦的个人博客</strong
      >&nbsp;</a
    >

    <button
      id="navbar-toggler-btn"
      class="navbar-toggler"
      type="button"
      data-toggle="collapse"
      data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent"
      aria-expanded="false"
      aria-label="Toggle navigation"
    >
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
            
        <li class="nav-item">
          <a class="nav-link" href="/">
            <i class="iconfont icon-home-fill"></i> 首页
          </a>
        </li>
             
        <li class="nav-item">
          <a class="nav-link" href="/archives/">
            <i class="iconfont icon-archive-fill"></i> 归档
          </a>
        </li>
             
        <li class="nav-item">
          <a class="nav-link" href="/categories/">
            <i class="iconfont icon-category-fill"></i> 分类
          </a>
        </li>
             
        <li class="nav-item">
          <a class="nav-link" href="/tags/">
            <i class="iconfont icon-tags-fill"></i> 标签
          </a>
        </li>
             
        <li class="nav-item">
          <a class="nav-link" href="/about/">
            <i class="iconfont icon-user-fill"></i> 关于
          </a>
        </li>
          
        <li class="nav-item" id="search-btn">
          <a class="nav-link" data-toggle="modal" data-target="#modalSearch"
            >&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a
          >
        </li>
         
        <li class="nav-item" id="color-toggle-btn">
          <a class="nav-link" href="javascript:;"
            >&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i
            >&nbsp;</a
          >
        </li>
         
        <li class="nav-item" id="music-toggle-btn">
          <a class="nav-link" href="javascript:;"
            >&nbsp;<i class="iconfont icon-music" id="music-toggle-icon"></i
            >&nbsp;</a
          ><audio id="player" loop>
            <source
              src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/Prospect.mp3"
              type="audio/mp3"
            />
          </audio>
        </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/test1.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JS正则表达式入门">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-16 00:00" pubdate>
        2021年12月16日
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      67
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JS正则表达式入门</h1>
            
            <div class="markdown-body">
              <h3 id="匹配文字字符串"><a href="#匹配文字字符串" class="headerlink" title="匹配文字字符串"></a>匹配文字字符串</h3><p>下面是一个在字符串中搜寻 <code>miqilin</code> 的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testStr = <span class="hljs-string">&quot;Hello, my name is miqilin.&quot;</span><br><span class="hljs-keyword">let</span> testRegex = <span class="hljs-regexp">/miqilin/</span><br><span class="hljs-built_in">console</span>.log(testRegex.test(testStr)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p>任何其他形式的 <code>miqilin</code> 都不会被匹配。 例如，正则表达式 <code>/miqilin/</code> 不会匹配 <code>Miqilin</code> 或者 <code>MIQILIN</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> wrongRegex = <span class="hljs-regexp">/Miqilin/</span><br><span class="hljs-built_in">console</span>.log(wrongRegex.test(testStr)) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<h3 id="同时用多种模式匹配文字字符串"><a href="#同时用多种模式匹配文字字符串" class="headerlink" title="同时用多种模式匹配文字字符串"></a>同时用多种模式匹配文字字符串</h3><p>上面的匹配文字字符串对于搜寻单个字符串非常有用，但仅限于一种匹配模式。你可以使用 <code>alternation</code> 或 <code>OR</code> 操作符搜索多个模式： <code>|</code>。</p>
<p>此操作符匹配操作符前面或后面的字符。 例如，如果你想匹配 <code>yes</code> 或 <code>no</code>，你需要的正则表达式是 <code>/yes|no/</code>。</p>
<p>你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。 这些匹配模式将包含更多的 <code>OR</code> 操作符来分隔它们，比如 <code>/yes|no|maybe/</code>。</p>
<h3 id="匹配时忽略大小写"><a href="#匹配时忽略大小写" class="headerlink" title="匹配时忽略大小写"></a>匹配时忽略大小写</h3><p>到目前为止，已经了解了如何用正则表达式来执行字符串的匹配。 但有时候，并不关注匹配字母的大小写。</p>
<p>这时候可以使用标志（flag）来匹配这两种情况。 标志有很多，不过这里我们只关注忽略大小写的标志——<code>i</code>。 可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 <code>/ignorecase/i</code>。 这个字符串可以匹配字符串 <code>ignorecase</code>、<code>igNoreCase</code> 和 <code>IgnoreCase</code>。</p>
<h3 id="提取匹配项"><a href="#提取匹配项" class="headerlink" title="提取匹配项"></a>提取匹配项</h3><p>到目前为止，只是检查了一个匹配模式是否存在于字符串中。 还可以使用 <code>.match()</code> 方法来提取找到的实际匹配项。</p>
<p>可以使用字符串来调用 <code>.match()</code> 方法，并在括号内传入正则表达式。</p>
<p>举例说明：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, World!&quot;</span>.match(<span class="hljs-regexp">/Hello/</span>)) <span class="hljs-comment">// [&quot;Hello&quot;]</span><br><span class="hljs-keyword">let</span> ourStr = <span class="hljs-string">&quot;Regular expressions&quot;</span><br><span class="hljs-keyword">let</span> ourRegex = <span class="hljs-regexp">/expressions/</span><br><span class="hljs-built_in">console</span>.log(ourStr.match(ourRegex)) <span class="hljs-comment">// [&quot;expressions&quot;]</span><br></code></pre></div></td></tr></table></figure>

<p>请注意， <code>.match</code> 语法是目前为止一直使用的 <code>.test</code> 方法中的“反向”：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-string">&#x27;string&#x27;</span>.match(<span class="hljs-regexp">/regex/</span>) <span class="hljs-comment">// 正则表达式在后</span><br>/regex/.test(<span class="hljs-string">&#x27;string&#x27;</span>) <span class="hljs-comment">// 正则表达式在前</span><br></code></pre></div></td></tr></table></figure>

<h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>到目前为止，只能提取或搜寻一次模式匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testStr = <span class="hljs-string">&quot;Repeat, Repeat, Repeat&quot;</span><br><span class="hljs-keyword">let</span> ourRegex = <span class="hljs-regexp">/Repeat/</span><br><span class="hljs-built_in">console</span>.log(testStr.match(ourRegex)) <span class="hljs-comment">// [&quot;Repeat&quot;]</span><br></code></pre></div></td></tr></table></figure>

<p>若要多次搜寻或提取模式匹配，可以使用 <code>g</code> 标志。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatRegex = <span class="hljs-regexp">/Repeat/g</span><br><span class="hljs-built_in">console</span>.log(testStr.match(repeatRegex)) <span class="hljs-comment">// [&quot;Repeat&quot;, &quot;Repeat&quot;, &quot;Repeat&quot;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="用通配符匹配任何内容"><a href="#用通配符匹配任何内容" class="headerlink" title="用通配符匹配任何内容"></a>用通配符匹配任何内容</h3><p>有时不（或不需要）知道匹配模式中的确切字符。 如果要精确匹配到完整的单词，那出现一个拼写错误就会匹配不到。 幸运的是，可以使用通配符 <code>.</code> 来处理这种情况。</p>
<p>通配符 <code>.</code> 将匹配任何一个字符。可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 <code>hug</code>、<code>huh</code>、<code>hut</code> 和 <code>hum</code>，可以使用正则表达式 <code>/hu./</code> 匹配以上四个单词。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> humStr = <span class="hljs-string">&quot;I&#x27;ll hum a song&quot;</span><br><span class="hljs-keyword">let</span> hugStr = <span class="hljs-string">&quot;Bear hug&quot;</span><br><span class="hljs-keyword">let</span> huRegex = <span class="hljs-regexp">/hu./</span><br>huRegex.test(humStr) <span class="hljs-comment">// true</span><br>huRegex.test(hugStr) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="将单个字符与多种可能性匹配"><a href="#将单个字符与多种可能性匹配" class="headerlink" title="将单个字符与多种可能性匹配"></a>将单个字符与多种可能性匹配</h3><p>上面了解了文字匹配模式（<code>/literal/</code>）和通配符（<code>/./</code>）。 这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。 在这两种极端情况之间有一个平衡选项。</p>
<p>可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（<code>[</code> 和 <code>]</code>）之间来定义一组需要匹配的字符串。</p>
<p>例如，如果想要匹配 <code>bag</code>、<code>big</code> 和 <code>bug</code>，但是不想匹配 <code>bog</code>。 可以创建正则表达式 <code>/b[aiu]g/</code> 来执行此操作。 <code>[aiu]</code> 是只匹配字符 <code>a</code>、<code>i</code> 或者 <code>u</code> 的字符集。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bigStr = <span class="hljs-string">&quot;big&quot;</span><br><span class="hljs-keyword">let</span> bagStr = <span class="hljs-string">&quot;bag&quot;</span><br><span class="hljs-keyword">let</span> bugStr = <span class="hljs-string">&quot;bug&quot;</span><br><span class="hljs-keyword">let</span> bogStr = <span class="hljs-string">&quot;bog&quot;</span><br><span class="hljs-keyword">let</span> bgRegex = <span class="hljs-regexp">/b[aiu]g/</span><br><span class="hljs-built_in">console</span>.log(bigStr.match(bgRegex), bagStr.match(bgRegex), bugStr.match(bgRegex), bogStr.match(bgRegex)) <span class="hljs-comment">// 按顺序打出 [&quot;big&quot;] [&quot;bag&quot;] [&quot;bug&quot;] null</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配字母表中的字母"><a href="#匹配字母表中的字母" class="headerlink" title="匹配字母表中的字母"></a>匹配字母表中的字母</h3><p>了解了如何使用字符集（character sets）来指定要匹配的一组字符串，但是有时需要匹配大量字符（例如，字母表中的每个字母）。 有一种写法可以让实现这个功能变得简短。</p>
<p>在字符集中，可以使用连字符（<code>-</code>）来定义要匹配的字符范围。</p>
<p>例如，要匹配小写字母 <code>a</code> 到 <code>e</code>，你可以使用 <code>[a-e]</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> catStr = <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-keyword">let</span> batStr = <span class="hljs-string">&quot;bat&quot;</span><br><span class="hljs-keyword">let</span> matStr = <span class="hljs-string">&quot;mat&quot;</span><br><span class="hljs-keyword">let</span> bgRegex = <span class="hljs-regexp">/[a-e]at/</span><br><span class="hljs-built_in">console</span>.log(catStr.match(bgRegex), batStr.match(bgRegex), matStr.match(bgRegex)) <span class="hljs-comment">// 按顺序打出 [&quot;cat&quot;] [&quot;bat&quot;] null</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配字母表中的数字和字母"><a href="#匹配字母表中的数字和字母" class="headerlink" title="匹配字母表中的数字和字母"></a>匹配字母表中的数字和字母</h3><p>使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。</p>
<p>例如，<code>/[0-5]/</code> 匹配 <code>0</code> 和 <code>5</code> 之间的任意数字，包含 <code>0</code> 和 <code>5</code>。</p>
<p>此外，还可以在单个字符集中组合一系列字母和数字。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> jennyStr = <span class="hljs-string">&quot;Jenny8675309&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/[a-z0-9]/ig</span><br><span class="hljs-built_in">console</span>.log(jennyStr.match(myRegex)) <span class="hljs-comment">// [&#x27;J&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;n&#x27;, &#x27;y&#x27;, &#x27;8&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;0&#x27;, &#x27;9&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配单个未指定的字符"><a href="#匹配单个未指定的字符" class="headerlink" title="匹配单个未指定的字符"></a>匹配单个未指定的字符</h3><p>到目前为止，已经创建了一个想要匹配的字符集合，但也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。</p>
<p>要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即<code>^</code>）。</p>
<p>例如，<code>/[^aeiou]/gi</code> 匹配所有非元音字符。 注意，字符 <code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code> 和空白字符等也会被匹配，该否定字符集仅排除元音字符。</p>
<p>比如创建一个匹配所有非数字或非元音字符的正则表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> quoteSample = <span class="hljs-string">&quot;3 blind mice.&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/[^aeiou^0-9]/gi</span><br><span class="hljs-built_in">console</span>.log(quoteSample.match(myRegex)) <span class="hljs-comment">// [&#x27; &#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;n&#x27;, &#x27;d&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;c&#x27;, &#x27;.&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="headerlink" title="匹配出现一次或多次的字符"></a>匹配出现一次或多次的字符</h3><p>有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。</p>
<p>可以使用 <code>+</code> 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。</p>
<p>例如，<code>/a+/g</code> 会在 <code>abc</code> 中匹配到一个匹配项，并且返回 <code>[&quot;a&quot;]</code>。 因为 <code>+</code> 的存在，它也会在 <code>aabc</code> 中匹配到一个匹配项，然后返回 <code>[&quot;aa&quot;]</code>。</p>
<p>如果它是检查字符串 <code>abab</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。 最后，因为在字符串 <code>bcd</code> 中没有 <code>a</code>，因此找不到匹配项。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> difficultSpelling = <span class="hljs-string">&quot;Mississippi&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/s+/g</span><br><span class="hljs-built_in">console</span>.log(difficultSpelling.match(myRegex)) <span class="hljs-comment">// [&#x27;ss&#x27;, &#x27;ss&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="headerlink" title="匹配出现零次或多次的字符"></a>匹配出现零次或多次的字符</h3><p>上面使用了加号 <code>+</code> 来查找出现一次或多次的字符。 还有一个选项可以匹配出现零次或多次的字符。执行该操作的字符为星号，即<code>*</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> soccerWord = <span class="hljs-string">&quot;gooooooooal!&quot;</span><br><span class="hljs-keyword">let</span> gPhrase = <span class="hljs-string">&quot;gut feeling&quot;</span><br><span class="hljs-keyword">let</span> oPhrase = <span class="hljs-string">&quot;over the moon&quot;</span><br><span class="hljs-keyword">let</span> goRegex = <span class="hljs-regexp">/go*/</span><br><span class="hljs-built_in">console</span>.log(soccerWord.match(goRegex), gPhrase.match(goRegex), oPhrase.match(goRegex)) <span class="hljs-comment">// [&quot;goooooooo&quot;] [&quot;g&quot;] null</span><br></code></pre></div></td></tr></table></figure>

<h3 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="headerlink" title="用惰性匹配来查找字符"></a>用惰性匹配来查找字符</h3><p>在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为惰性（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p>
<p>可以将正则表达式 <code>/t[a-z]*i/</code> 应用于字符串 <code>&quot;titanic&quot;</code>。 这个正则表达式是一个以 <code>t</code> 开始，以 <code>i</code> 结束，并且中间有一些字母的匹配模式。</p>
<p>正则表达式默认是贪婪匹配，因此匹配返回为 <code>[&quot;titani&quot;]</code>。 它会匹配到适合该匹配模式的最大子字符串。</p>
<p>但是，你可以使用 <code>?</code> 字符来将其变成惰性匹配。 调整后的正则表达式 <code>/t[a-z]*?i/</code> 匹配字符串 <code>&quot;titanic&quot;</code> 返回 <code>[&quot;ti&quot;]</code>。</p>
<p><strong>注意</strong>：应该避免使用正则表达式解析 HTML，但是可以用正则表达式匹配 HTML 字符串。</p>
<p>让下面匹配结果返回 HTML 标签 <code>&lt;h1&gt;</code>，而不是文本 <code>&quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/&lt;.*?&gt;/</span><br><span class="hljs-built_in">console</span>.log(text.match(myRegex)) <span class="hljs-comment">// [&#x27;&lt;h1&gt;&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配字符串的开头"><a href="#匹配字符串的开头" class="headerlink" title="匹配字符串的开头"></a>匹配字符串的开头</h3><p>在<a href="#%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E6%9C%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6">匹配单个未指定的字符</a>中使用（<code>^</code>）符号来创建一个否定字符集，形如 <code>[^thingsThatWillNotBeMatched]</code>。 除了在字符集中使用之外，脱字符还用于匹配字符串的开始位置。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> firstString = <span class="hljs-string">&quot;Ricky is first and can be found.&quot;</span><br><span class="hljs-keyword">let</span> firstRegex = <span class="hljs-regexp">/^Ricky/</span><br><span class="hljs-built_in">console</span>.log(firstRegex.test(firstString)) <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> notFirst = <span class="hljs-string">&quot;You can&#x27;t find Ricky now.&quot;</span><br><span class="hljs-built_in">console</span>.log(firstRegex.test(notFirst)) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配字符串的末尾"><a href="#匹配字符串的末尾" class="headerlink" title="匹配字符串的末尾"></a>匹配字符串的末尾</h3><p>可以使用正则表达式的美元符号 <code>$</code> 来搜寻字符串的结尾。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> theEnding = <span class="hljs-string">&quot;This is a never ending story&quot;</span><br><span class="hljs-keyword">let</span> storyRegex = <span class="hljs-regexp">/story$/</span><br><span class="hljs-built_in">console</span>.log(storyRegex.test(theEnding)) <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> noEnding = <span class="hljs-string">&quot;Sometimes a story will have to end&quot;</span><br><span class="hljs-built_in">console</span>.log(storyRegex.test(noEnding)) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="headerlink" title="匹配所有的字母和数字"></a>匹配所有的字母和数字</h3><p>使用元字符，可以使用 <code>[a-z]</code> 搜寻字母表中的所有字母。 这种元字符是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p>
<p>js 中与字母表匹配的最接近的元字符是<code>\w</code>。 这个缩写等同于<code>[A-Za-z0-9_]</code>。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (<code>_</code>)。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> longHand = <span class="hljs-regexp">/[A-Za-z0-9_]+/</span><br><span class="hljs-keyword">let</span> shortHand = <span class="hljs-regexp">/\w+/</span><br><span class="hljs-keyword">let</span> numbers = <span class="hljs-string">&quot;42&quot;</span><br><span class="hljs-keyword">let</span> varNames = <span class="hljs-string">&quot;important_var&quot;</span><br>longHand.test(numbers)<br>shortHand.test(numbers)<br>longHand.test(varNames)<br>shortHand.test(varNames)<br></code></pre></div></td></tr></table></figure>

<p>上面的 <code>test</code> 都会返回 <code>true</code>。</p>
<p>这些元字符缩写也被称为短语元字符 shorthand character classes。</p>
<p>使用元字符 <code>\w</code> 来计算所有引号中字母和数字字符的数量：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> quoteSample = <span class="hljs-string">&quot;The five boxing wizards jump quickly.&quot;</span><br><span class="hljs-keyword">let</span> alphabetRegexV2 = <span class="hljs-regexp">/\w/g</span><br><span class="hljs-built_in">console</span>.log(quoteSample.match(alphabetRegexV2).length) <span class="hljs-comment">// 31</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="headerlink" title="匹配除了字母和数字的所有符号"></a>匹配除了字母和数字的所有符号</h3><p>上面描述了可以使用缩写 <code>\w</code> 来匹配字母和数字 <code>[A-Za-z0-9_]</code>。 不过，有可能想要搜寻的匹配模式是非字母数字字符。</p>
<p>可以使用 <code>\W</code> 搜寻和 <code>\w</code> 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 <code>[^A-Za-z0-9_]</code> 是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> shortHand = <span class="hljs-regexp">/\W/</span><br><span class="hljs-keyword">let</span> numbers = <span class="hljs-string">&quot;42%&quot;</span><br><span class="hljs-keyword">let</span> sentence = <span class="hljs-string">&quot;Coding!&quot;</span><br><span class="hljs-built_in">console</span>.log(numbers.match(shortHand), sentence.match(shortHand)) <span class="hljs-comment">// [&quot;%&quot;]  [&quot;!&quot;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配所有数字"><a href="#匹配所有数字" class="headerlink" title="匹配所有数字"></a>匹配所有数字</h3><p>已经了解了常见字符串匹配模式的元字符，如字母数字。 另一个常见的匹配模式是只寻找数字。</p>
<p>查找数字字符的缩写是 <code>\d</code>，注意是小写的 <code>d</code>。 这等同于元字符 <code>[0-9]</code>，它查找 <code>0</code> 到 <code>9</code> 之间任意数字的单个字符。</p>
<p>使用缩写 <code>\d</code> 来计算电影标题中有多少个数字：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> movieName = <span class="hljs-string">&quot;2001: A Space Odyssey&quot;</span><br><span class="hljs-keyword">let</span> numRegex = <span class="hljs-regexp">/\d/g</span><br><span class="hljs-built_in">console</span>.log(movieName.match(numRegex).length) <span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配所有非数字"><a href="#匹配所有非数字" class="headerlink" title="匹配所有非数字"></a>匹配所有非数字</h3><p>上面展示了如何使用带有小写 <code>d</code> 的缩写 <code>\d</code> 来搜寻数字。 也可以使用类似的缩写来搜寻非数字，该缩写使用大写的 <code>D</code>。</p>
<p>查找非数字字符的缩写是 <code>\D</code>。 这等同于字符串 <code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p>
<p>使用非数字缩写 <code>\D</code> 来计算电影标题中有多少非数字：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> movieName = <span class="hljs-string">&quot;2001: A Space Odyssey&quot;</span><br><span class="hljs-keyword">let</span> noNumRegex = <span class="hljs-regexp">/\D/g</span><br><span class="hljs-built_in">console</span>.log(movieName.match(noNumRegex).length) <span class="hljs-comment">// 17</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>迄今为止介绍的都是匹配字母和数字。 还可以匹配字符之间的空格。</p>
<p>可以使用 <code>\s</code> 搜寻空格，其中 <code>s</code> 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[ \r\t\f\n\v]</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> whiteSpace = <span class="hljs-string">&quot;Whitespace. Whitespace everywhere!&quot;</span><br><span class="hljs-keyword">let</span> spaceRegex = <span class="hljs-regexp">/\s/g</span><br><span class="hljs-built_in">console</span>.log(whiteSpace.match(spaceRegex)) <span class="hljs-comment">// [&#x27; &#x27;, &#x27; &#x27;]</span><br></code></pre></div></td></tr></table></figure>

<h3 id="匹配非空白字符"><a href="#匹配非空白字符" class="headerlink" title="匹配非空白字符"></a>匹配非空白字符</h3><p>已经学会了如何使用带有小写 <code>s</code> 的缩写 <code>\s</code> 来搜寻空白字符。 还可以搜寻除了空格之外的所有内容。</p>
<p>使用 <code>\S</code> 搜寻非空白字符，其中 <code>S</code> 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[^ \r\t\f\n\v]</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> whiteSpace = <span class="hljs-string">&quot;Whitespace. Whitespace everywhere!&quot;</span><br><span class="hljs-keyword">let</span> nonSpaceRegex = <span class="hljs-regexp">/\S/g</span><br><span class="hljs-built_in">console</span>.log(whiteSpace.match(nonSpaceRegex).length) <span class="hljs-comment">// 32</span><br></code></pre></div></td></tr></table></figure>

<h3 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h3><p>回想一下，使用加号 <code>+</code> 查找一个或多个字符，使用星号 <code>*</code> 查找零个或多个字符。 这些都很方便，但有时需要匹配一定范围的匹配模式。</p>
<p>可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（<code>&#123;</code> 和 <code>&#125;</code>）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p>
<p>例如，要匹配出现 <code>3</code> 到 <code>5</code> 次字母 <code>a</code> 的在字符串 <code>ah</code>，正则表达式应为<code>/a&#123;3,5&#125;h/</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> A4 = <span class="hljs-string">&quot;aaaah&quot;</span><br><span class="hljs-keyword">let</span> A2 = <span class="hljs-string">&quot;aah&quot;</span><br><span class="hljs-keyword">let</span> multipleA = <span class="hljs-regexp">/a&#123;3,5&#125;h/</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A4)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A2)) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<p>匹配出现 <code>3</code> 到 <code>6</code> 次字母 <code>h</code> 的字符串 <code>Oh no</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ohStr = <span class="hljs-string">&quot;Ohhh no&quot;</span><br><span class="hljs-keyword">let</span> ohRegex = <span class="hljs-regexp">/Oh&#123;3,6&#125;\sno/</span><br><span class="hljs-built_in">console</span>.log(ohRegex.test(ohStr)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="只指定匹配的下限"><a href="#只指定匹配的下限" class="headerlink" title="只指定匹配的下限"></a>只指定匹配的下限</h3><p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时候只想指定匹配模式的下限而不需要指定上限。</p>
<p>为此，在第一个数字后面跟一个逗号即可。</p>
<p>例如，要匹配至少出现 <code>3</code> 次字母 <code>a</code> 的字符串 <code>hah</code>，正则表达式应该是 <code>/ha&#123;3,&#125;h/</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> A4 = <span class="hljs-string">&quot;haaaah&quot;</span><br><span class="hljs-keyword">let</span> A2 = <span class="hljs-string">&quot;haah&quot;</span><br><span class="hljs-keyword">let</span> A100 = <span class="hljs-string">&quot;h&quot;</span> + <span class="hljs-string">&quot;a&quot;</span>.repeat(<span class="hljs-number">100</span>) + <span class="hljs-string">&quot;h&quot;</span><br><span class="hljs-keyword">let</span> multipleA = <span class="hljs-regexp">/ha&#123;3,&#125;h/</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A4)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A2)) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A100)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="headerlink" title="指定匹配的确切数量"></a>指定匹配的确切数量</h3><p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时只需要特定数量的匹配。</p>
<p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p>
<p>例如，要只匹配字母 <code>a</code> 出现 <code>3</code> 次的单词hah，正则表达式应为<code>/ha&#123;3&#125;h/</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> A4 = <span class="hljs-string">&quot;haaaah&quot;</span><br><span class="hljs-keyword">let</span> A3 = <span class="hljs-string">&quot;haaah&quot;</span><br><span class="hljs-keyword">let</span> A100 = <span class="hljs-string">&quot;h&quot;</span> + <span class="hljs-string">&quot;a&quot;</span>.repeat(<span class="hljs-number">100</span>) + <span class="hljs-string">&quot;h&quot;</span><br><span class="hljs-keyword">let</span> multipleHA = <span class="hljs-regexp">/ha&#123;3&#125;h/</span><br><span class="hljs-built_in">console</span>.log(multipleHA.test(A4)) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(multipleHA.test(A3)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(multipleHA.test(A100)) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<h3 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h3><p>有时，想要搜寻的匹配模式可能有不确定是否存在的部分。 尽管如此，还是想检查它们。</p>
<p>为此，可以使用问号 <code>?</code> 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。</p>
<p>例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> american = <span class="hljs-string">&quot;color&quot;</span><br><span class="hljs-keyword">let</span> british = <span class="hljs-string">&quot;colour&quot;</span><br><span class="hljs-keyword">let</span> rainbowRegex= <span class="hljs-regexp">/colou?r/</span><br><span class="hljs-built_in">console</span>.log(rainbowRegex.test(american)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(rainbowRegex.test(british)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h3><p>先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。</p>
<p>有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。</p>
<p>正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 <code>(?=...)</code>，其中 <code>...</code> 就是需要存在但不会被匹配的部分。</p>
<p>另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 <code>(?!...)</code>，其中 <code>...</code> 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p>
<p>尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> quit = <span class="hljs-string">&quot;qu&quot;</span><br><span class="hljs-keyword">let</span> noquit = <span class="hljs-string">&quot;qt&quot;</span><br><span class="hljs-keyword">let</span> quRegex= <span class="hljs-regexp">/q(?=u)/</span><br><span class="hljs-keyword">let</span> qRegex = <span class="hljs-regexp">/q(?!u)/</span><br><span class="hljs-built_in">console</span>.log(quit.match(quRegex)) <span class="hljs-comment">// [&quot;q&quot;]</span><br><span class="hljs-built_in">console</span>.log(noquit.match(qRegex)) <span class="hljs-comment">// [&quot;q&quot;]</span><br></code></pre></div></td></tr></table></figure>

<p>先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> password = <span class="hljs-string">&quot;abc123&quot;</span><br><span class="hljs-keyword">let</span> checkPass = <span class="hljs-regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span><br><span class="hljs-built_in">console</span>.log(checkPass.test(password)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p>使用先行断言以匹配大于 5 个字符且有两个连续数字的密码：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sampleWord1 = <span class="hljs-string">&quot;astronaut&quot;</span><br><span class="hljs-keyword">let</span> sampleWord2 = <span class="hljs-string">&quot;astronaut12&quot;</span><br><span class="hljs-keyword">let</span> pwRegex =  <span class="hljs-regexp">/(?=\w&#123;6&#125;)(?=\w*\d&#123;2&#125;)/</span><br><span class="hljs-built_in">console</span>.log(pwRegex.test(sampleWord1)) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(pwRegex.test(sampleWord2)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="检查混合字符组"><a href="#检查混合字符组" class="headerlink" title="检查混合字符组"></a>检查混合字符组</h3><p>有时候我们想使用正则表达式里的括号 <code>()</code> 来检查字符组。</p>
<p>如果想在字符串找到 <code>Penguin</code> 或 <code>Pumpkin</code>，可以用这个正则表达式：<code>/P(engu|umpk)in/g</code>。</p>
<p>然后使用 <code>test()</code> 方法检查 test 字符串里面是否包含字符组。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testStr = <span class="hljs-string">&quot;Pumpkin&quot;</span><br><span class="hljs-keyword">let</span> testRegex = <span class="hljs-regexp">/P(engu|umpk)in/</span><br><span class="hljs-built_in">console</span>.log(testRegex.test(testStr)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="使用捕获组重用模式"><a href="#使用捕获组重用模式" class="headerlink" title="使用捕获组重用模式"></a>使用捕获组重用模式</h3><p>当你想要匹配一个像下面这样多次出现的单词：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatStr = <span class="hljs-string">&quot;row row row your boat&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>你可以使用 <code>/row row row/</code>。但如果你不知道重复的特定单词，怎么办？ <em>捕获组</em> 可以用于找到重复的子字符串。</p>
<p>捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 <code>\w+</code> 放在括号中：<code>/(\w+)/</code>。</p>
<p>分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：<code>\1</code>）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。</p>
<p>下面的示例是匹配被空格隔开的两个相同单词：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatRegex = <span class="hljs-regexp">/(\w+) \1 \1/</span><br><span class="hljs-built_in">console</span>.log(repeatRegex.test(repeatStr)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(repeatStr.match(repeatRegex)) <span class="hljs-comment">// [&quot;row row row&quot;, &quot;row&quot;]</span><br></code></pre></div></td></tr></table></figure>

<p>在字符串上调用 <code>.match()</code> 方法将返回一个数组，其中包含它最终匹配到的子字符串及其捕获组。</p>
<p>再来一个例子加深印象：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testString = <span class="hljs-string">&quot;test test test&quot;</span><br><span class="hljs-keyword">let</span> reRegex = <span class="hljs-regexp">/(test)(\s)\1\2\1/</span><br><span class="hljs-built_in">console</span>.log(reRegex.test(testString)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p><code>\1</code> 代表重复的 <code>(test)</code>；<code>\2</code> 代表重复的 <code>(\s)</code>。</p>
<p>使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatNum = <span class="hljs-string">&quot;42 42 42&quot;</span><br><span class="hljs-keyword">let</span> reRegex = <span class="hljs-regexp">/^(\d+)\s\1\s\1$/</span><br><span class="hljs-built_in">console</span>.log(reRegex.test(repeatNum)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<h3 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h3><p>搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p>
<p>可以在字符串上使用 <code>.replace()</code> 方法来搜索并替换字符串中的文本。 <code>.replace()</code> 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> wrongText = <span class="hljs-string">&quot;The sky is silver.&quot;</span><br><span class="hljs-keyword">let</span> silverRegex = <span class="hljs-regexp">/silver/</span><br>wrongText.replace(silverRegex, <span class="hljs-string">&quot;blue&quot;</span>)<br></code></pre></div></td></tr></table></figure>

<p><code>replace</code> 调用将返回字符串 <code>The sky is blue.</code>。</p>
<p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-string">&quot;Code Camp&quot;</span>.replace(<span class="hljs-regexp">/(\w+)\s(\w+)/</span>, <span class="hljs-string">&#x27;$2 $1&#x27;</span>)<br></code></pre></div></td></tr></table></figure>

<p>调用 <code>replace</code> 将返回字符串 <code>Camp Code</code>。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="限制可能的用户名"><a href="#限制可能的用户名" class="headerlink" title="限制可能的用户名"></a>限制可能的用户名</h4><p>用户名在互联网上随处可见。 它们是用户在自己喜欢的网站上的唯一身份。</p>
<p>需要检索数据库中的所有用户名。 以下是用户在创建用户名时必须遵守的一些简单规则。</p>
<ol>
<li><p>用户名只能是数字字母字符。</p>
</li>
<li><p>用户名中的数字必须在最后。 数字可以有零个或多个。 用户名不能以数字开头。</p>
</li>
<li><p>用户名字母可以是小写字母和大写字母。</p>
</li>
<li><p>用户名长度必须至少为两个字符。 两位用户名只能使用字母。</p>
</li>
</ol>
<p>解法1：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> username = <span class="hljs-string">&quot;JackOfAllTrades&quot;</span><br><span class="hljs-keyword">let</span> userCheck = <span class="hljs-regexp">/^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i</span><br><span class="hljs-keyword">let</span> result = userCheck.test(username)<br><span class="hljs-built_in">console</span>.log(result)<br></code></pre></div></td></tr></table></figure>

<p>解法2：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> username = <span class="hljs-string">&quot;JackOfAllTrades&quot;</span>;<br><span class="hljs-keyword">const</span> userCheck = <span class="hljs-regexp">/^[a-z]([0-9]&#123;2,&#125;|[a-z]+\d*)$/i</span>;<br><span class="hljs-keyword">let</span> result = userCheck.test(username);<br></code></pre></div></td></tr></table></figure>

<h4 id="删除开头和结尾的空白"><a href="#删除开头和结尾的空白" class="headerlink" title="删除开头和结尾的空白"></a>删除开头和结尾的空白</h4><p>有时字符串周围存在的空白字符并不是必需的。 字符串的典型处理是删除字符串开头和结尾处的空格。</p>
<p>编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。</p>
<p><strong>注意</strong>： <code>String.prototype.trim()</code> 方法在这里也可以实现同样的效果，但是你需要使用正则表达式来完成此项挑战。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;   Hello, World!  &quot;</span><br><span class="hljs-keyword">let</span> wsRegex = <span class="hljs-regexp">/^\s+|\s+$/g</span><br><span class="hljs-keyword">let</span> result = hello.replace(wsRegex, <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">// result = &quot;Hello, World!&quot;</span><br></code></pre></div></td></tr></table></figure>

<p>另一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ts = <span class="hljs-string">&quot;.mjsx?a=1&quot;</span><br><span class="hljs-keyword">let</span> tsRegex = <span class="hljs-regexp">/\.([cm])?(js)(x?)/</span><br><span class="hljs-keyword">let</span> result = ts.replace(tsRegex, <span class="hljs-string">&quot;.$1ts$3&quot;</span>) <span class="hljs-comment">// result = &quot;.mtsx?a=1&quot;</span><br></code></pre></div></td></tr></table></figure>

<p><code>$n</code> 代表插入第 <code>n</code> 个括号匹配的字符串，索引是从1开始。<code>$1</code> 代表 <code>([cm])?</code> 匹配到的字符，即 <code>hello</code> 中的 <code>m</code>；<code>$3</code> 代表 <code>(x?)</code> 匹配到的字符，即 <code>hello</code> 中的 <code>x</code>。</p>
<p><strong>如果觉得文章对你有些许帮助，欢迎在<a target="_blank" rel="noopener" href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JavaScript/">JavaScript</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%AD%A3%E5%88%99/">正则</a>
                    
                      <a class="hover-with-bg" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
                    
                      <a class="hover-with-bg" href="/tags/regex/">regex</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/01/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%9C%A8github%E4%B8%8A%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/">
                        <span class="hidden-mobile">你知道如何高效地在GitHub搜索开源项目吗?</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content"> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> </div>
  灵谦的个人博客 2019–2021 
 
 
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
