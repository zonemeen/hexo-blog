<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灵谦的个人博客</title>
  
  <subtitle>亲亲 这边建议您要多喝热水哦</subtitle>
  <link href="https://me.miqilin21.cn/atom.xml" rel="self"/>
  
  <link href="https://me.miqilin21.cn/"/>
  <updated>2021-12-16T03:19:39.127Z</updated>
  <id>https://me.miqilin21.cn/</id>
  
  <author>
    <name>miqilin21</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式入门</title>
    <link href="https://me.miqilin21.cn/2021/12/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>https://me.miqilin21.cn/2021/12/16/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/</id>
    <published>2021-12-15T16:00:00.000Z</published>
    <updated>2021-12-16T03:19:39.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="匹配文字字符串"><a href="#匹配文字字符串" class="headerlink" title="匹配文字字符串"></a>匹配文字字符串</h3><p>下面是一个在字符串中搜寻 <code>miqilin</code> 的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testStr = <span class="hljs-string">&quot;Hello, my name is miqilin.&quot;</span><br><span class="hljs-keyword">let</span> testRegex = <span class="hljs-regexp">/miqilin/</span><br><span class="hljs-built_in">console</span>.log(testRegex.test(testStr)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>任何其他形式的 <code>miqilin</code> 都不会被匹配。 例如，正则表达式 <code>/miqilin/</code> 不会匹配 <code>Miqilin</code> 或者 <code>MIQILIN</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> wrongRegex = <span class="hljs-regexp">/Miqilin/</span><br><span class="hljs-built_in">console</span>.log(wrongRegex.test(testStr)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="同时用多种模式匹配文字字符串"><a href="#同时用多种模式匹配文字字符串" class="headerlink" title="同时用多种模式匹配文字字符串"></a>同时用多种模式匹配文字字符串</h3><p>上面的匹配文字字符串对于搜寻单个字符串非常有用，但仅限于一种匹配模式。你可以使用 <code>alternation</code> 或 <code>OR</code> 操作符搜索多个模式： <code>|</code>。</p><p>此操作符匹配操作符前面或后面的字符。 例如，如果你想匹配 <code>yes</code> 或 <code>no</code>，你需要的正则表达式是 <code>/yes|no/</code>。</p><p>你还可以匹配多个规则，这可以通过添加更多的匹配模式来实现。 这些匹配模式将包含更多的 <code>OR</code> 操作符来分隔它们，比如 <code>/yes|no|maybe/</code>。</p><h3 id="匹配时忽略大小写"><a href="#匹配时忽略大小写" class="headerlink" title="匹配时忽略大小写"></a>匹配时忽略大小写</h3><p>到目前为止，已经了解了如何用正则表达式来执行字符串的匹配。 但有时候，并不关注匹配字母的大小写。</p><p>这时候可以使用标志（flag）来匹配这两种情况。 标志有很多，不过这里我们只关注忽略大小写的标志——<code>i</code>。 可以通过将它附加到正则表达式之后来使用它。 这里给出使用该标志的一个实例 <code>/ignorecase/i</code>。 这个字符串可以匹配字符串 <code>ignorecase</code>、<code>igNoreCase</code> 和 <code>IgnoreCase</code>。</p><h3 id="提取匹配项"><a href="#提取匹配项" class="headerlink" title="提取匹配项"></a>提取匹配项</h3><p>到目前为止，只是检查了一个匹配模式是否存在于字符串中。 还可以使用 <code>.match()</code> 方法来提取找到的实际匹配项。</p><p>可以使用字符串来调用 <code>.match()</code> 方法，并在括号内传入正则表达式。</p><p>举例说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello, World!&quot;</span>.match(<span class="hljs-regexp">/Hello/</span>)) <span class="hljs-comment">// [&quot;Hello&quot;]</span><br><span class="hljs-keyword">let</span> ourStr = <span class="hljs-string">&quot;Regular expressions&quot;</span><br><span class="hljs-keyword">let</span> ourRegex = <span class="hljs-regexp">/expressions/</span><br><span class="hljs-built_in">console</span>.log(ourStr.match(ourRegex)) <span class="hljs-comment">// [&quot;expressions&quot;]</span><br></code></pre></td></tr></table></figure><p>请注意， <code>.match</code> 语法是目前为止一直使用的 <code>.test</code> 方法中的“反向”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;string&#x27;</span>.match(<span class="hljs-regexp">/regex/</span>) <span class="hljs-comment">// 正则表达式在后</span><br>/regex/.test(<span class="hljs-string">&#x27;string&#x27;</span>) <span class="hljs-comment">// 正则表达式在前</span><br></code></pre></td></tr></table></figure><h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>到目前为止，只能提取或搜寻一次模式匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testStr = <span class="hljs-string">&quot;Repeat, Repeat, Repeat&quot;</span><br><span class="hljs-keyword">let</span> ourRegex = <span class="hljs-regexp">/Repeat/</span><br><span class="hljs-built_in">console</span>.log(testStr.match(ourRegex)) <span class="hljs-comment">// [&quot;Repeat&quot;]</span><br></code></pre></td></tr></table></figure><p>若要多次搜寻或提取模式匹配，可以使用 <code>g</code> 标志。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatRegex = <span class="hljs-regexp">/Repeat/g</span><br><span class="hljs-built_in">console</span>.log(testStr.match(repeatRegex)) <span class="hljs-comment">// [&quot;Repeat&quot;, &quot;Repeat&quot;, &quot;Repeat&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="用通配符匹配任何内容"><a href="#用通配符匹配任何内容" class="headerlink" title="用通配符匹配任何内容"></a>用通配符匹配任何内容</h3><p>有时不（或不需要）知道匹配模式中的确切字符。 如果要精确匹配到完整的单词，那出现一个拼写错误就会匹配不到。 幸运的是，可以使用通配符 <code>.</code> 来处理这种情况。</p><p>通配符 <code>.</code> 将匹配任何一个字符。可以像使用正则表达式中任何其他字符一样使用通配符。 例如，如果想匹配 <code>hug</code>、<code>huh</code>、<code>hut</code> 和 <code>hum</code>，可以使用正则表达式 <code>/hu./</code> 匹配以上四个单词。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> humStr = <span class="hljs-string">&quot;I&#x27;ll hum a song&quot;</span><br><span class="hljs-keyword">let</span> hugStr = <span class="hljs-string">&quot;Bear hug&quot;</span><br><span class="hljs-keyword">let</span> huRegex = <span class="hljs-regexp">/hu./</span><br>huRegex.test(humStr) <span class="hljs-comment">// true</span><br>huRegex.test(hugStr) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="将单个字符与多种可能性匹配"><a href="#将单个字符与多种可能性匹配" class="headerlink" title="将单个字符与多种可能性匹配"></a>将单个字符与多种可能性匹配</h3><p>上面了解了文字匹配模式（<code>/literal/</code>）和通配符（<code>/./</code>）。 这是正则表达式的两种极端情况，一种是精确匹配，而另一种则是匹配所有。 在这两种极端情况之间有一个平衡选项。</p><p>可以使用字符集 （character classes）更灵活的匹配字符。 可以把字符集放在方括号（<code>[</code> 和 <code>]</code>）之间来定义一组需要匹配的字符串。</p><p>例如，如果想要匹配 <code>bag</code>、<code>big</code> 和 <code>bug</code>，但是不想匹配 <code>bog</code>。 可以创建正则表达式 <code>/b[aiu]g/</code> 来执行此操作。 <code>[aiu]</code> 是只匹配字符 <code>a</code>、<code>i</code> 或者 <code>u</code> 的字符集。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bigStr = <span class="hljs-string">&quot;big&quot;</span><br><span class="hljs-keyword">let</span> bagStr = <span class="hljs-string">&quot;bag&quot;</span><br><span class="hljs-keyword">let</span> bugStr = <span class="hljs-string">&quot;bug&quot;</span><br><span class="hljs-keyword">let</span> bogStr = <span class="hljs-string">&quot;bog&quot;</span><br><span class="hljs-keyword">let</span> bgRegex = <span class="hljs-regexp">/b[aiu]g/</span><br><span class="hljs-built_in">console</span>.log(bigStr.match(bgRegex), bagStr.match(bgRegex), bugStr.match(bgRegex), bogStr.match(bgRegex)) <span class="hljs-comment">// 按顺序打出 [&quot;big&quot;] [&quot;bag&quot;] [&quot;bug&quot;] null</span><br></code></pre></td></tr></table></figure><h3 id="匹配字母表中的字母"><a href="#匹配字母表中的字母" class="headerlink" title="匹配字母表中的字母"></a>匹配字母表中的字母</h3><p>了解了如何使用字符集（character sets）来指定要匹配的一组字符串，但是有时需要匹配大量字符（例如，字母表中的每个字母）。 有一种写法可以让实现这个功能变得简短。</p><p>在字符集中，可以使用连字符（<code>-</code>）来定义要匹配的字符范围。</p><p>例如，要匹配小写字母 <code>a</code> 到 <code>e</code>，你可以使用 <code>[a-e]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> catStr = <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-keyword">let</span> batStr = <span class="hljs-string">&quot;bat&quot;</span><br><span class="hljs-keyword">let</span> matStr = <span class="hljs-string">&quot;mat&quot;</span><br><span class="hljs-keyword">let</span> bgRegex = <span class="hljs-regexp">/[a-e]at/</span><br><span class="hljs-built_in">console</span>.log(catStr.match(bgRegex), batStr.match(bgRegex), matStr.match(bgRegex)) <span class="hljs-comment">// 按顺序打出 [&quot;cat&quot;] [&quot;bat&quot;] null</span><br></code></pre></td></tr></table></figure><h3 id="匹配字母表中的数字和字母"><a href="#匹配字母表中的数字和字母" class="headerlink" title="匹配字母表中的数字和字母"></a>匹配字母表中的数字和字母</h3><p>使用连字符（<code>-</code>）匹配字符范围并不仅限于字母。 它还可以匹配一系列数字。</p><p>例如，<code>/[0-5]/</code> 匹配 <code>0</code> 和 <code>5</code> 之间的任意数字，包含 <code>0</code> 和 <code>5</code>。</p><p>此外，还可以在单个字符集中组合一系列字母和数字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> jennyStr = <span class="hljs-string">&quot;Jenny8675309&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/[a-z0-9]/ig</span><br><span class="hljs-built_in">console</span>.log(jennyStr.match(myRegex)) <span class="hljs-comment">// [&#x27;J&#x27;, &#x27;e&#x27;, &#x27;n&#x27;, &#x27;n&#x27;, &#x27;y&#x27;, &#x27;8&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;5&#x27;, &#x27;3&#x27;, &#x27;0&#x27;, &#x27;9&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配单个未指定的字符"><a href="#匹配单个未指定的字符" class="headerlink" title="匹配单个未指定的字符"></a>匹配单个未指定的字符</h3><p>到目前为止，已经创建了一个想要匹配的字符集合，但也可以创建一个不想匹配的字符集合。 这些类型的字符集称为否定字符集（ negated character sets）。</p><p>要创建否定字符集，需要在开始括号后面和不想匹配的字符前面放置脱字符（即<code>^</code>）。</p><p>例如，<code>/[^aeiou]/gi</code> 匹配所有非元音字符。 注意，字符 <code>.</code>、<code>!</code>、<code>[</code>、<code>@</code>、<code>/</code> 和空白字符等也会被匹配，该否定字符集仅排除元音字符。</p><p>比如创建一个匹配所有非数字或非元音字符的正则表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> quoteSample = <span class="hljs-string">&quot;3 blind mice.&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/[^aeiou^0-9]/gi</span><br><span class="hljs-built_in">console</span>.log(quoteSample.match(myRegex)) <span class="hljs-comment">// [&#x27; &#x27;, &#x27;b&#x27;, &#x27;l&#x27;, &#x27;n&#x27;, &#x27;d&#x27;, &#x27; &#x27;, &#x27;m&#x27;, &#x27;c&#x27;, &#x27;.&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配出现一次或多次的字符"><a href="#匹配出现一次或多次的字符" class="headerlink" title="匹配出现一次或多次的字符"></a>匹配出现一次或多次的字符</h3><p>有时，需要匹配出现一次或者连续多次的的字符（或字符组）。 这意味着它至少出现一次，并且可能重复出现。</p><p>可以使用 <code>+</code> 符号来检查情况是否如此。 记住，字符或匹配模式必须一个接一个地连续出现。 这就是说，字符必须一个接一个地重复。</p><p>例如，<code>/a+/g</code> 会在 <code>abc</code> 中匹配到一个匹配项，并且返回 <code>[&quot;a&quot;]</code>。 因为 <code>+</code> 的存在，它也会在 <code>aabc</code> 中匹配到一个匹配项，然后返回 <code>[&quot;aa&quot;]</code>。</p><p>如果它是检查字符串 <code>abab</code>，它将匹配到两个匹配项并且返回<code>[&quot;a&quot;, &quot;a&quot;]</code>，因为<code>a</code>字符不连续，在它们之间有一个<code>b</code>字符。 最后，因为在字符串 <code>bcd</code> 中没有 <code>a</code>，因此找不到匹配项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> difficultSpelling = <span class="hljs-string">&quot;Mississippi&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/s+/g</span><br><span class="hljs-built_in">console</span>.log(difficultSpelling.match(myRegex)) <span class="hljs-comment">// [&#x27;ss&#x27;, &#x27;ss&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配出现零次或多次的字符"><a href="#匹配出现零次或多次的字符" class="headerlink" title="匹配出现零次或多次的字符"></a>匹配出现零次或多次的字符</h3><p>上面使用了加号 <code>+</code> 来查找出现一次或多次的字符。 还有一个选项可以匹配出现零次或多次的字符。执行该操作的字符为星号，即<code>*</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> soccerWord = <span class="hljs-string">&quot;gooooooooal!&quot;</span><br><span class="hljs-keyword">let</span> gPhrase = <span class="hljs-string">&quot;gut feeling&quot;</span><br><span class="hljs-keyword">let</span> oPhrase = <span class="hljs-string">&quot;over the moon&quot;</span><br><span class="hljs-keyword">let</span> goRegex = <span class="hljs-regexp">/go*/</span><br><span class="hljs-built_in">console</span>.log(soccerWord.match(goRegex), gPhrase.match(goRegex), oPhrase.match(goRegex)) <span class="hljs-comment">// [&quot;goooooooo&quot;] [&quot;g&quot;] null</span><br></code></pre></td></tr></table></figure><h3 id="用惰性匹配来查找字符"><a href="#用惰性匹配来查找字符" class="headerlink" title="用惰性匹配来查找字符"></a>用惰性匹配来查找字符</h3><p>在正则表达式中，贪婪（greedy）匹配会匹配到符合正则表达式匹配模式的字符串的最长可能部分，并将其作为匹配项返回。 另一种方案称为惰性（lazy）匹配，它会匹配到满足正则表达式的字符串的最小可能部分。</p><p>可以将正则表达式 <code>/t[a-z]*i/</code> 应用于字符串 <code>&quot;titanic&quot;</code>。 这个正则表达式是一个以 <code>t</code> 开始，以 <code>i</code> 结束，并且中间有一些字母的匹配模式。</p><p>正则表达式默认是贪婪匹配，因此匹配返回为 <code>[&quot;titani&quot;]</code>。 它会匹配到适合该匹配模式的最大子字符串。</p><p>但是，你可以使用 <code>?</code> 字符来将其变成惰性匹配。 调整后的正则表达式 <code>/t[a-z]*?i/</code> 匹配字符串 <code>&quot;titanic&quot;</code> 返回 <code>[&quot;ti&quot;]</code>。</p><p><strong>注意</strong>：应该避免使用正则表达式解析 HTML，但是可以用正则表达式匹配 HTML 字符串。</p><p>让下面匹配结果返回 HTML 标签 <code>&lt;h1&gt;</code>，而不是文本 <code>&quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;&lt;h1&gt;Winter is coming&lt;/h1&gt;&quot;</span><br><span class="hljs-keyword">let</span> myRegex = <span class="hljs-regexp">/&lt;.*?&gt;/</span><br><span class="hljs-built_in">console</span>.log(text.match(myRegex)) <span class="hljs-comment">// [&#x27;&lt;h1&gt;&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配字符串的开头"><a href="#匹配字符串的开头" class="headerlink" title="匹配字符串的开头"></a>匹配字符串的开头</h3><p>在<a href="#%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E6%9C%AA%E6%8C%87%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6">匹配单个未指定的字符</a>中使用（<code>^</code>）符号来创建一个否定字符集，形如 <code>[^thingsThatWillNotBeMatched]</code>。 除了在字符集中使用之外，脱字符还用于匹配字符串的开始位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> firstString = <span class="hljs-string">&quot;Ricky is first and can be found.&quot;</span><br><span class="hljs-keyword">let</span> firstRegex = <span class="hljs-regexp">/^Ricky/</span><br><span class="hljs-built_in">console</span>.log(firstRegex.test(firstString)) <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> notFirst = <span class="hljs-string">&quot;You can&#x27;t find Ricky now.&quot;</span><br><span class="hljs-built_in">console</span>.log(firstRegex.test(notFirst)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="匹配字符串的末尾"><a href="#匹配字符串的末尾" class="headerlink" title="匹配字符串的末尾"></a>匹配字符串的末尾</h3><p>可以使用正则表达式的美元符号 <code>$</code> 来搜寻字符串的结尾。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> theEnding = <span class="hljs-string">&quot;This is a never ending story&quot;</span><br><span class="hljs-keyword">let</span> storyRegex = <span class="hljs-regexp">/story$/</span><br><span class="hljs-built_in">console</span>.log(storyRegex.test(theEnding)) <span class="hljs-comment">// true</span><br><span class="hljs-keyword">let</span> noEnding = <span class="hljs-string">&quot;Sometimes a story will have to end&quot;</span><br><span class="hljs-built_in">console</span>.log(storyRegex.test(noEnding)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="匹配所有的字母和数字"><a href="#匹配所有的字母和数字" class="headerlink" title="匹配所有的字母和数字"></a>匹配所有的字母和数字</h3><p>使用元字符，可以使用 <code>[a-z]</code> 搜寻字母表中的所有字母。 这种元字符是很常见的，它有一个缩写，但这个缩写也包含额外的字符。</p><p>js 中与字母表匹配的最接近的元字符是<code>\w</code>。 这个缩写等同于<code>[A-Za-z0-9_]</code>。 此字符类匹配大写字母和小写字母以及数字。 注意，这个字符类也包含下划线字符 (<code>_</code>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> longHand = <span class="hljs-regexp">/[A-Za-z0-9_]+/</span><br><span class="hljs-keyword">let</span> shortHand = <span class="hljs-regexp">/\w+/</span><br><span class="hljs-keyword">let</span> numbers = <span class="hljs-string">&quot;42&quot;</span><br><span class="hljs-keyword">let</span> varNames = <span class="hljs-string">&quot;important_var&quot;</span><br>longHand.test(numbers)<br>shortHand.test(numbers)<br>longHand.test(varNames)<br>shortHand.test(varNames)<br></code></pre></td></tr></table></figure><p>上面的 <code>test</code> 都会返回 <code>true</code>。</p><p>这些元字符缩写也被称为短语元字符 shorthand character classes。</p><p>使用元字符 <code>\w</code> 来计算所有引号中字母和数字字符的数量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> quoteSample = <span class="hljs-string">&quot;The five boxing wizards jump quickly.&quot;</span><br><span class="hljs-keyword">let</span> alphabetRegexV2 = <span class="hljs-regexp">/\w/g</span><br><span class="hljs-built_in">console</span>.log(quoteSample.match(alphabetRegexV2).length) <span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure><h3 id="匹配除了字母和数字的所有符号"><a href="#匹配除了字母和数字的所有符号" class="headerlink" title="匹配除了字母和数字的所有符号"></a>匹配除了字母和数字的所有符号</h3><p>上面描述了可以使用缩写 <code>\w</code> 来匹配字母和数字 <code>[A-Za-z0-9_]</code>。 不过，有可能想要搜寻的匹配模式是非字母数字字符。</p><p>可以使用 <code>\W</code> 搜寻和 <code>\w</code> 相反的匹配模式。 注意，相反匹配模式使用大写字母。 此缩写与 <code>[^A-Za-z0-9_]</code> 是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> shortHand = <span class="hljs-regexp">/\W/</span><br><span class="hljs-keyword">let</span> numbers = <span class="hljs-string">&quot;42%&quot;</span><br><span class="hljs-keyword">let</span> sentence = <span class="hljs-string">&quot;Coding!&quot;</span><br><span class="hljs-built_in">console</span>.log(numbers.match(shortHand), sentence.match(shortHand)) <span class="hljs-comment">// [&quot;%&quot;]  [&quot;!&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配所有数字"><a href="#匹配所有数字" class="headerlink" title="匹配所有数字"></a>匹配所有数字</h3><p>已经了解了常见字符串匹配模式的元字符，如字母数字。 另一个常见的匹配模式是只寻找数字。</p><p>查找数字字符的缩写是 <code>\d</code>，注意是小写的 <code>d</code>。 这等同于元字符 <code>[0-9]</code>，它查找 <code>0</code> 到 <code>9</code> 之间任意数字的单个字符。</p><p>使用缩写 <code>\d</code> 来计算电影标题中有多少个数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> movieName = <span class="hljs-string">&quot;2001: A Space Odyssey&quot;</span><br><span class="hljs-keyword">let</span> numRegex = <span class="hljs-regexp">/\d/g</span><br><span class="hljs-built_in">console</span>.log(movieName.match(numRegex).length) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="匹配所有非数字"><a href="#匹配所有非数字" class="headerlink" title="匹配所有非数字"></a>匹配所有非数字</h3><p>上面展示了如何使用带有小写 <code>d</code> 的缩写 <code>\d</code> 来搜寻数字。 也可以使用类似的缩写来搜寻非数字，该缩写使用大写的 <code>D</code>。</p><p>查找非数字字符的缩写是 <code>\D</code>。 这等同于字符串 <code>[^0-9]</code>，它查找不是 0 - 9 之间数字的单个字符。</p><p>使用非数字缩写 <code>\D</code> 来计算电影标题中有多少非数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> movieName = <span class="hljs-string">&quot;2001: A Space Odyssey&quot;</span><br><span class="hljs-keyword">let</span> noNumRegex = <span class="hljs-regexp">/\D/g</span><br><span class="hljs-built_in">console</span>.log(movieName.match(noNumRegex).length) <span class="hljs-comment">// 17</span><br></code></pre></td></tr></table></figure><h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>迄今为止介绍的都是匹配字母和数字。 还可以匹配字符之间的空格。</p><p>可以使用 <code>\s</code> 搜寻空格，其中 <code>s</code> 是小写。 此匹配模式将匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[ \r\t\f\n\v]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> whiteSpace = <span class="hljs-string">&quot;Whitespace. Whitespace everywhere!&quot;</span><br><span class="hljs-keyword">let</span> spaceRegex = <span class="hljs-regexp">/\s/g</span><br><span class="hljs-built_in">console</span>.log(whiteSpace.match(spaceRegex)) <span class="hljs-comment">// [&#x27; &#x27;, &#x27; &#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="匹配非空白字符"><a href="#匹配非空白字符" class="headerlink" title="匹配非空白字符"></a>匹配非空白字符</h3><p>已经学会了如何使用带有小写 <code>s</code> 的缩写 <code>\s</code> 来搜寻空白字符。 还可以搜寻除了空格之外的所有内容。</p><p>使用 <code>\S</code> 搜寻非空白字符，其中 <code>S</code> 是大写。 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。 可以认为这类似于元字符 <code>[^ \r\t\f\n\v]</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> whiteSpace = <span class="hljs-string">&quot;Whitespace. Whitespace everywhere!&quot;</span><br><span class="hljs-keyword">let</span> nonSpaceRegex = <span class="hljs-regexp">/\S/g</span><br><span class="hljs-built_in">console</span>.log(whiteSpace.match(nonSpaceRegex).length) <span class="hljs-comment">// 32</span><br></code></pre></td></tr></table></figure><h3 id="指定匹配的上限和下限"><a href="#指定匹配的上限和下限" class="headerlink" title="指定匹配的上限和下限"></a>指定匹配的上限和下限</h3><p>回想一下，使用加号 <code>+</code> 查找一个或多个字符，使用星号 <code>*</code> 查找零个或多个字符。 这些都很方便，但有时需要匹配一定范围的匹配模式。</p><p>可以使用数量说明符（quantity specifiers）指定匹配模式的上下限。 数量说明符与花括号（<code>&#123;</code> 和 <code>&#125;</code>）一起使用。 可以在花括号之间放两个数字，这两个数字代表匹配模式的上限和下限。</p><p>例如，要匹配出现 <code>3</code> 到 <code>5</code> 次字母 <code>a</code> 的在字符串 <code>ah</code>，正则表达式应为<code>/a&#123;3,5&#125;h/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> A4 = <span class="hljs-string">&quot;aaaah&quot;</span><br><span class="hljs-keyword">let</span> A2 = <span class="hljs-string">&quot;aah&quot;</span><br><span class="hljs-keyword">let</span> multipleA = <span class="hljs-regexp">/a&#123;3,5&#125;h/</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A4)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A2)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>匹配出现 <code>3</code> 到 <code>6</code> 次字母 <code>h</code> 的字符串 <code>Oh no</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ohStr = <span class="hljs-string">&quot;Ohhh no&quot;</span><br><span class="hljs-keyword">let</span> ohRegex = <span class="hljs-regexp">/Oh&#123;3,6&#125;\sno/</span><br><span class="hljs-built_in">console</span>.log(ohRegex.test(ohStr)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="只指定匹配的下限"><a href="#只指定匹配的下限" class="headerlink" title="只指定匹配的下限"></a>只指定匹配的下限</h3><p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时候只想指定匹配模式的下限而不需要指定上限。</p><p>为此，在第一个数字后面跟一个逗号即可。</p><p>例如，要匹配至少出现 <code>3</code> 次字母 <code>a</code> 的字符串 <code>hah</code>，正则表达式应该是 <code>/ha&#123;3,&#125;h/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> A4 = <span class="hljs-string">&quot;haaaah&quot;</span><br><span class="hljs-keyword">let</span> A2 = <span class="hljs-string">&quot;haah&quot;</span><br><span class="hljs-keyword">let</span> A100 = <span class="hljs-string">&quot;h&quot;</span> + <span class="hljs-string">&quot;a&quot;</span>.repeat(<span class="hljs-number">100</span>) + <span class="hljs-string">&quot;h&quot;</span><br><span class="hljs-keyword">let</span> multipleA = <span class="hljs-regexp">/ha&#123;3,&#125;h/</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A4)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A2)) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(multipleA.test(A100)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="指定匹配的确切数量"><a href="#指定匹配的确切数量" class="headerlink" title="指定匹配的确切数量"></a>指定匹配的确切数量</h3><p>可以使用带有花括号的数量说明符来指定匹配模式的上下限。 但有时只需要特定数量的匹配。</p><p>要指定一定数量的匹配模式，只需在大括号之间放置一个数字。</p><p>例如，要只匹配字母 <code>a</code> 出现 <code>3</code> 次的单词hah，正则表达式应为<code>/ha&#123;3&#125;h/</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> A4 = <span class="hljs-string">&quot;haaaah&quot;</span><br><span class="hljs-keyword">let</span> A3 = <span class="hljs-string">&quot;haaah&quot;</span><br><span class="hljs-keyword">let</span> A100 = <span class="hljs-string">&quot;h&quot;</span> + <span class="hljs-string">&quot;a&quot;</span>.repeat(<span class="hljs-number">100</span>) + <span class="hljs-string">&quot;h&quot;</span><br><span class="hljs-keyword">let</span> multipleHA = <span class="hljs-regexp">/ha&#123;3&#125;h/</span><br><span class="hljs-built_in">console</span>.log(multipleHA.test(A4)) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(multipleHA.test(A3)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(multipleHA.test(A100)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="检查全部或无"><a href="#检查全部或无" class="headerlink" title="检查全部或无"></a>检查全部或无</h3><p>有时，想要搜寻的匹配模式可能有不确定是否存在的部分。 尽管如此，还是想检查它们。</p><p>为此，可以使用问号 <code>?</code> 指定可能存在的元素。 这将检查前面的零个或一个元素。 可以将此符号视为前面的元素是可选的。</p><p>例如，美式英语和英式英语略有不同，可以使用问号来匹配两种拼写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> american = <span class="hljs-string">&quot;color&quot;</span><br><span class="hljs-keyword">let</span> british = <span class="hljs-string">&quot;colour&quot;</span><br><span class="hljs-keyword">let</span> rainbowRegex= <span class="hljs-regexp">/colou?r/</span><br><span class="hljs-built_in">console</span>.log(rainbowRegex.test(american)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(rainbowRegex.test(british)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="正向先行断言和负向先行断言"><a href="#正向先行断言和负向先行断言" class="headerlink" title="正向先行断言和负向先行断言"></a>正向先行断言和负向先行断言</h3><p>先行断言 （Lookaheads）是告诉 JavaScript 在字符串中向前查找的匹配模式。 当想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。</p><p>有两种先行断言：正向先行断言（positive lookahead）和负向先行断言（negative lookahead）。</p><p>正向先行断言会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。 正向先行断言的用法是 <code>(?=...)</code>，其中 <code>...</code> 就是需要存在但不会被匹配的部分。</p><p>另一方面，负向先行断言会查看并确保搜索匹配模式中的元素不存在。 负向先行断言的用法是 <code>(?!...)</code>，其中 <code>...</code> 是希望不存在的匹配模式。 如果负向先行断言部分不存在，将返回匹配模式的其余部分。</p><p>尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> quit = <span class="hljs-string">&quot;qu&quot;</span><br><span class="hljs-keyword">let</span> noquit = <span class="hljs-string">&quot;qt&quot;</span><br><span class="hljs-keyword">let</span> quRegex= <span class="hljs-regexp">/q(?=u)/</span><br><span class="hljs-keyword">let</span> qRegex = <span class="hljs-regexp">/q(?!u)/</span><br><span class="hljs-built_in">console</span>.log(quit.match(quRegex)) <span class="hljs-comment">// [&quot;q&quot;]</span><br><span class="hljs-built_in">console</span>.log(noquit.match(qRegex)) <span class="hljs-comment">// [&quot;q&quot;]</span><br></code></pre></td></tr></table></figure><p>先行断言的更实际用途是检查一个字符串中的两个或更多匹配模式。 这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> password = <span class="hljs-string">&quot;abc123&quot;</span><br><span class="hljs-keyword">let</span> checkPass = <span class="hljs-regexp">/(?=\w&#123;3,6&#125;)(?=\D*\d)/</span><br><span class="hljs-built_in">console</span>.log(checkPass.test(password)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>使用先行断言以匹配大于 5 个字符且有两个连续数字的密码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> sampleWord1 = <span class="hljs-string">&quot;astronaut&quot;</span><br><span class="hljs-keyword">let</span> sampleWord2 = <span class="hljs-string">&quot;astronaut12&quot;</span><br><span class="hljs-keyword">let</span> pwRegex =  <span class="hljs-regexp">/(?=\w&#123;6&#125;)(?=\w*\d&#123;2&#125;)/</span><br><span class="hljs-built_in">console</span>.log(pwRegex.test(sampleWord1)) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(pwRegex.test(sampleWord2)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="检查混合字符组"><a href="#检查混合字符组" class="headerlink" title="检查混合字符组"></a>检查混合字符组</h3><p>有时候我们想使用正则表达式里的括号 <code>()</code> 来检查字符组。</p><p>如果想在字符串找到 <code>Penguin</code> 或 <code>Pumpkin</code>，可以用这个正则表达式：<code>/P(engu|umpk)in/g</code>。</p><p>然后使用 <code>test()</code> 方法检查 test 字符串里面是否包含字符组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testStr = <span class="hljs-string">&quot;Pumpkin&quot;</span><br><span class="hljs-keyword">let</span> testRegex = <span class="hljs-regexp">/P(engu|umpk)in/</span><br><span class="hljs-built_in">console</span>.log(testRegex.test(testStr)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="使用捕获组重用模式"><a href="#使用捕获组重用模式" class="headerlink" title="使用捕获组重用模式"></a>使用捕获组重用模式</h3><p>当你想要匹配一个像下面这样多次出现的单词：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatStr = <span class="hljs-string">&quot;row row row your boat&quot;</span><br></code></pre></td></tr></table></figure><p>你可以使用 <code>/row row row/</code>。但如果你不知道重复的特定单词，怎么办？ <em>捕获组</em> 可以用于找到重复的子字符串。</p><p>捕获组是通过把要捕获的正则表达式放在括号中来构建的。 在这个例子里， 目标是捕获一个包含字母数字字符的词，所以捕获组是将 <code>\w+</code> 放在括号中：<code>/(\w+)/</code>。</p><p>分组匹配的子字符串被保存到一个临时的“变量”， 可以使用同一正则表达式和反斜线及捕获组的编号来访问它（例如：<code>\1</code>）。 捕获组按其开头括号的位置自动编号（从左到右），从 1 开始。</p><p>下面的示例是匹配被空格隔开的两个相同单词：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatRegex = <span class="hljs-regexp">/(\w+) \1 \1/</span><br><span class="hljs-built_in">console</span>.log(repeatRegex.test(repeatStr)) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(repeatStr.match(repeatRegex)) <span class="hljs-comment">// [&quot;row row row&quot;, &quot;row&quot;]</span><br></code></pre></td></tr></table></figure><p>在字符串上调用 <code>.match()</code> 方法将返回一个数组，其中包含它最终匹配到的子字符串及其捕获组。</p><p>再来一个例子加深印象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> testString = <span class="hljs-string">&quot;test test test&quot;</span><br><span class="hljs-keyword">let</span> reRegex = <span class="hljs-regexp">/(test)(\s)\1\2\1/</span><br><span class="hljs-built_in">console</span>.log(reRegex.test(testString)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>\1</code> 代表重复的 <code>(test)</code>；<code>\2</code> 代表重复的 <code>(\s)</code>。</p><p>使用捕获组来匹配一个只由相同的数字重复三次组成的由空格分隔字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> repeatNum = <span class="hljs-string">&quot;42 42 42&quot;</span><br><span class="hljs-keyword">let</span> reRegex = <span class="hljs-regexp">/^(\d+)\s\1\s\1$/</span><br><span class="hljs-built_in">console</span>.log(reRegex.test(repeatNum)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="使用捕获组搜索和替换"><a href="#使用捕获组搜索和替换" class="headerlink" title="使用捕获组搜索和替换"></a>使用捕获组搜索和替换</h3><p>搜索功能是很有用的。 但是，当搜索同时也执行更改（或替换）匹配文本的操作时，搜索功能就会显得更加强大。</p><p>可以在字符串上使用 <code>.replace()</code> 方法来搜索并替换字符串中的文本。 <code>.replace()</code> 的输入首先是想要搜索的正则表达式匹配模式。 第二个参数是用于替换匹配的字符串或用于执行某些操作的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> wrongText = <span class="hljs-string">&quot;The sky is silver.&quot;</span><br><span class="hljs-keyword">let</span> silverRegex = <span class="hljs-regexp">/silver/</span><br>wrongText.replace(silverRegex, <span class="hljs-string">&quot;blue&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>replace</code> 调用将返回字符串 <code>The sky is blue.</code>。</p><p>你还可以使用美元符号（<code>$</code>）访问替换字符串中的捕获组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&quot;Code Camp&quot;</span>.replace(<span class="hljs-regexp">/(\w+)\s(\w+)/</span>, <span class="hljs-string">&#x27;$2 $1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>调用 <code>replace</code> 将返回字符串 <code>Camp Code</code>。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="限制可能的用户名"><a href="#限制可能的用户名" class="headerlink" title="限制可能的用户名"></a>限制可能的用户名</h4><p>用户名在互联网上随处可见。 它们是用户在自己喜欢的网站上的唯一身份。</p><p>需要检索数据库中的所有用户名。 以下是用户在创建用户名时必须遵守的一些简单规则。</p><ol><li><p>用户名只能是数字字母字符。</p></li><li><p>用户名中的数字必须在最后。 数字可以有零个或多个。 用户名不能以数字开头。</p></li><li><p>用户名字母可以是小写字母和大写字母。</p></li><li><p>用户名长度必须至少为两个字符。 两位用户名只能使用字母。</p></li></ol><p>解法1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> username = <span class="hljs-string">&quot;JackOfAllTrades&quot;</span><br><span class="hljs-keyword">let</span> userCheck = <span class="hljs-regexp">/^[a-z][a-z]+\d*$|^[a-z]\d\d+$/i</span><br><span class="hljs-keyword">let</span> result = userCheck.test(username)<br><span class="hljs-built_in">console</span>.log(result)<br></code></pre></td></tr></table></figure><p>解法2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> username = <span class="hljs-string">&quot;JackOfAllTrades&quot;</span>;<br><span class="hljs-keyword">const</span> userCheck = <span class="hljs-regexp">/^[a-z]([0-9]&#123;2,&#125;|[a-z]+\d*)$/i</span>;<br><span class="hljs-keyword">let</span> result = userCheck.test(username);<br></code></pre></td></tr></table></figure><h4 id="删除开头和结尾的空白"><a href="#删除开头和结尾的空白" class="headerlink" title="删除开头和结尾的空白"></a>删除开头和结尾的空白</h4><p>有时字符串周围存在的空白字符并不是必需的。 字符串的典型处理是删除字符串开头和结尾处的空格。</p><p>编写一个正则表达式并使用适当的字符串方法删除字符串开头和结尾的空格。</p><p><strong>注意</strong>： <code>String.prototype.trim()</code> 方法在这里也可以实现同样的效果，但是你需要使用正则表达式来完成此项挑战。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> hello = <span class="hljs-string">&quot;   Hello, World!  &quot;</span><br><span class="hljs-keyword">let</span> wsRegex = <span class="hljs-regexp">/^\s+|\s+$/g</span><br><span class="hljs-keyword">let</span> result = hello.replace(wsRegex, <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">// result = &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;匹配文字字符串&quot;&gt;&lt;a href=&quot;#匹配文字字符串&quot; class=&quot;headerlink&quot; title=&quot;匹配文字字符串&quot;&gt;&lt;/a&gt;匹配文字字符串&lt;/h3&gt;&lt;p&gt;下面是一个在字符串中搜寻 &lt;code&gt;miqilin&lt;/code&gt; 的示例：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="正则" scheme="https://me.miqilin21.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
    <category term="正则表达式" scheme="https://me.miqilin21.cn/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    <category term="regex" scheme="https://me.miqilin21.cn/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>你知道如何高效地在GitHub搜索开源项目吗?</title>
    <link href="https://me.miqilin21.cn/2021/12/01/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%9C%A8github%E4%B8%8A%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://me.miqilin21.cn/2021/12/01/%E4%BD%A0%E7%9F%A5%E9%81%93%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%9C%A8github%E4%B8%8A%E6%89%BE%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-16T03:04:59.591Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个常逛 GitHub 的程序员，你真的知道如何高效地在 GitHub 搜索开源项目吗？你的操作是不是单纯的在搜索框内输入关键词进行搜索的？嘿嘿，这篇文章就来告诉你有啥搜索的技巧或者说骚操作吧。</p><p>先来看看直接在搜索框内输入关键词所搜索出来的内容吧（以搜 vue 项目为例）：</p><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-1.png"></p><p>what？竟然找到了 48 多万个相关的开源项目，这时候很多人就不清楚下一步应该干啥了，也不清楚具体找哪个项目练手学习。</p><p>所以下面教你几个精确查找项目的方法。</p><h3 id="GitHub-项目的精确查找"><a href="#GitHub-项目的精确查找" class="headerlink" title="GitHub 项目的精确查找"></a>GitHub 项目的精确查找</h3><h4 id="1-项目名称关键字搜索"><a href="#1-项目名称关键字搜索" class="headerlink" title="1. 项目名称关键字搜索"></a>1. 项目名称关键字搜索</h4><p>搜索方式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">in</span>:<span class="hljs-built_in">name</span> 项目名称关键词<br></code></pre></td></tr></table></figure><p>以下图片都以 vue 项目为例：</p><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-2.png"></p><p>这样会发现比单纯搜关键词时的项目量少了一些，并且会将关键词加粗，但搜索出的量还是有点大。</p><h4 id="2-项目描述关键字搜索"><a href="#2-项目描述关键字搜索" class="headerlink" title="2. 项目描述关键字搜索"></a>2. 项目描述关键字搜索</h4><p>搜索方式：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>description 项目描述关键词<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-3.png"></p><p>这样也是会比单纯搜关键词时的项目量少了一半多些了，但搜索出的量还是很大的。</p><h4 id="3-项目-README-关键字搜索"><a href="#3-项目-README-关键字搜索" class="headerlink" title="3. 项目 README 关键字搜索"></a>3. 项目 README 关键字搜索</h4><p>搜索方式：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>readme readme关键词<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-4.png"></p><p>发现搜索出的量只增不减的，那还有什么方式能更加精准的搜索呢？</p><p>就是利用上面的<strong>三种搜索关键字搜索+以下四种限制条件</strong>来更加精确的搜索。</p><h4 id="4-限制项目的-stars-数或者-forks-数"><a href="#4-限制项目的-stars-数或者-forks-数" class="headerlink" title="4. 限制项目的 stars 数或者 forks 数"></a>4. 限制项目的 stars 数或者 forks 数</h4><p>一般情况下一个项目的 star 或 fork 数多少，是能代表该项目的受欢迎程度的，能很大程度地筛选掉一些比较水的项目。搜索方式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">in:</span>name或description或readme 关键字 <span class="hljs-attr">stars:</span>&gt;数字 <span class="hljs-attr">forks:</span>&gt;数字<br></code></pre></td></tr></table></figure><p>其中 <code>stars:&gt;数字</code> 可以单独使用，也可和 <code>forks:&gt;数字</code> 结合使用，还是以搜 vue 项目为例：</p><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-5.png"></p><p>只是加了一个对 stars 数大于 1000 的限制条件，这时候发现搜出的项目量是不是少了很多？这个搜索技巧很强大吧。</p><h4 id="5-限制项目的更新时间"><a href="#5-限制项目的更新时间" class="headerlink" title="5. 限制项目的更新时间"></a>5. 限制项目的更新时间</h4><p>我们在确认是否要使用一些开源框架、库的时候，是否继续维护是很重要的一点。如果是已经过时没人维护的项目，踩坑就不好解决了。搜索方式：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">in</span>:name或description或readme 关键字 stars:&gt;数字 pushed:&gt;<span class="hljs-number">2020</span><span class="hljs-number">-06</span><span class="hljs-number">-01</span><br></code></pre></td></tr></table></figure><p>上面的 <code>pushed:&gt;2020-06-01</code> 搜到的是 2020 年 6 月 1 号之后还在更新的项目，外加限制 stars 数：</p><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-6.png"></p><p>搜索结果进一步的精确了，如果你是想找指定时间之前或之后创建的仓库也是可以的，把 pushed 改成 <strong>created</strong> 就行了。</p><h4 id="6-限制项目的语言"><a href="#6-限制项目的语言" class="headerlink" title="6. 限制项目的语言"></a>6. 限制项目的语言</h4><p>比如想找 JavaScript 的库， 除了像在搜索结果左侧点击选择语言之外，还可以在搜索中过滤。搜索方式：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">in:</span>name或description或readme 关键字 <span class="hljs-attr">stars:</span>&gt;数字 <span class="hljs-attr">pushed:</span>&gt;<span class="hljs-number">2020</span><span class="hljs-number">-06</span><span class="hljs-number">-01</span> <span class="hljs-attr">language:</span>javascript<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-7.png"></p><p>这时候的搜索结果已经相当精确了。</p><h4 id="7-限制项目的作者或组织"><a href="#7-限制项目的作者或组织" class="headerlink" title="7. 限制项目的作者或组织"></a>7. 限制项目的作者或组织</h4><p>如果想在 GitHub 上找一下某个大佬提交了什么新的功能，就可以指定其 github 名后搜索，例如咱们想看下尤大（github 名：yyx990803）近期有没有提交新的 JS 代码，其搜索方式：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">user</span>:yyx<span class="hljs-number">990803</span><br></code></pre></td></tr></table></figure><p>如果想找某个组织的代码的话，紧接着第 6 条的搜索条件，可以这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">in:</span>name vue <span class="hljs-attr">stars:</span>&gt;<span class="hljs-number">1000</span> <span class="hljs-attr">pushed:</span>&gt;<span class="hljs-number">2020</span><span class="hljs-number">-06</span><span class="hljs-number">-01</span> <span class="hljs-attr">language:</span>javascript <span class="hljs-attr">org:</span>vuejs<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/miqilin21/static@master/img/gitopensource-8.png"></p><p>最终搜索数量定格在 16 条，这个搜索使用起来是不是相当的便捷精确呢?</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如何高效的从 GitHub 上搜索开源项目，有下面的小技巧（三类关键字搜索+四限制）：</p><ul><li>项目名关键字搜索: <code>in:name 项目名关键字</code></li><li>项目描述关键字搜索： <code>in:description 项目名关键字</code></li><li>项目详细描述关键字搜索： <code>in:readme 项目名关键字</code></li><li>限制项目的火热程度： <code>stars:&gt;数字 或者 forks:&gt;数字</code></li><li>限制项目的更新时间：<code>pushed:&gt;时间</code></li><li>限制项目的语言：<code>language:语言</code></li><li>限制项目的作者或组织：<code>user:作者名 或者 org:组织名</code></li></ul><p>上面的这些命令都可以组合使用，这样可以使得项目搜索更加精确。</p><p>你可以实践试一试这样的搜索技巧，看看是否能找到你想要的开源项目呢？</p><p>延伸阅读：</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3MTEwODc5Ng==&mid=2650859642&idx=1&sn=9b2c2dc61686c580f8af1dc8fc197612&chksm=f13297a9c6451ebf083e5335eb2ae4eba0f8c80bc8db420ce7e0aac90eaeb06152f589dcaf6e&scene=21#wechat_redirect">怎样参与到全世界优秀的开源项目中?</a></p></blockquote><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一个常逛 GitHub 的程序员，你真的知道如何高效地在 GitHub 搜索开源项目吗？你的操作是不是单纯的在搜索框内输入关键词进行搜索的？嘿嘿，这篇文章就来告诉你有啥搜索的技巧或者说骚操作吧。&lt;/p&gt;
&lt;p&gt;先来看看直接在搜索框内输入关键词所搜索出来的内容吧（以搜 v</summary>
      
    
    
    
    <category term="OpenSource" scheme="https://me.miqilin21.cn/categories/OpenSource/"/>
    
    
    <category term="GitHub" scheme="https://me.miqilin21.cn/tags/GitHub/"/>
    
    <category term="OpenSource" scheme="https://me.miqilin21.cn/tags/OpenSource/"/>
    
  </entry>
  
  <entry>
    <title>前端必备英语词汇，你了解多少呢？</title>
    <link href="https://me.miqilin21.cn/2021/10/12/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%E5%91%A2/"/>
    <id>https://me.miqilin21.cn/2021/10/12/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%B1%87%EF%BC%8C%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%E5%91%A2/</id>
    <published>2021-10-11T16:00:00.000Z</published>
    <updated>2021-12-16T03:05:14.502Z</updated>
    
    <content type="html"><![CDATA[<p>掌握前端开发过程中常用的英语词汇还是非常有必要的，现整理出一些前端英语词汇，希望对从事前端的你有所帮助。</p><h2 id="前端常用英语词汇表"><a href="#前端常用英语词汇表" class="headerlink" title="前端常用英语词汇表"></a>前端常用英语词汇表</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>abstraction 抽象、抽象物、抽象性</p><p>access 存取、访问</p><p>account 账户</p><p>action 动作</p><p>activate 激活</p><p>adapter 适配器</p><p>address 地址</p><p>advanced 高级的</p><p>aggregation 聚合、聚集</p><p>algorithm 算法</p><p>alias 别名</p><p>align 排列、对齐</p><p>allocate 分配、配置</p><p>allocator 分配器、配置器</p><p>annotation 注解、评注</p><p>anonymous function 匿名函数</p><p>append 附加</p><p>application 应用、应用程序</p><p>architecture 架构、体系结构</p><p>argument 参数</p><p>array 数组</p><p>arrow 箭头</p><p>assert(ion) 断言</p><p>assign 赋值</p><p>assignment 赋值、分配</p><p>associated 相关的、相关联的</p><p>asynchronous 异步的</p><p>attribute 特性、属性</p><p>augmented 扩充</p><p>authentication 验证</p><p>authorization 授权</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>background 背景、后台（进程）</p><p>backup 备份</p><p>backup device 备份设备</p><p>backup file 备份文件</p><p>backward compatible 向后兼容、向下兼容</p><p>base class 基类</p><p>batch 批处理、批量</p><p>binary tree 二叉树</p><p>binding 绑定</p><p>block 块、区块、语句块</p><p>bound 边界</p><p>brace 花括弧、花括号</p><p>bracket 方括弧、方括号</p><p>buffer 缓冲区</p><p>bug 缺陷错误</p><p>build 编译</p><p>built-in 内建、内置</p><p>business 业务、商务</p><p>business logic 业务逻辑</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>cache 缓存</p><p>call 调用</p><p>callback 回调</p><p>case 分支</p><p>casting 转型、造型转换</p><p>catalog 目录</p><p>chain 链</p><p>character 字符</p><p>chunk 块</p><p>class 类</p><p>class declaration 类声明</p><p>class definition 类定义</p><p>class hierachy 类层次结构</p><p>classification 分类</p><p>clause 子句</p><p>cleanup 清理、清除</p><p>client 客户、客户端</p><p>clipboard 剪贴板</p><p>clone 克隆</p><p>closure 闭包</p><p>collection 集合</p><p>column 行</p><p>command-line 命令行</p><p>command-line interface, CLI 命令行界面</p><p>comment 注释</p><p>commit 提交</p><p>communication 通讯</p><p>compatible 兼容</p><p>compile 编译</p><p>compiler 编译器</p><p>complexity 复杂度</p><p>component 组件</p><p>compression 压缩</p><p>concept 概念</p><p>concrete 具体</p><p>concurrency 并发</p><p>configuration 配置、组态</p><p>connection 连接</p><p>console 控制台</p><p>constant 常量</p><p>construct 构件、成分、概念、构造</p><p>container 容器</p><p>context 环境、上下文</p><p>control 控件</p><p>copy 拷贝、复制</p><p>cover 覆盖、涵盖</p><p>create/creation 创建、生成</p><p>cube 多维数据集</p><p>currying 柯里化</p><p>cursor 光标</p><p>custom 定制</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>data 数据</p><p>data structure 数据结构</p><p>data type 数据类型</p><p>database 数据库</p><p>dataset 数据集</p><p>deallocate 归还</p><p>debug 调试</p><p>debugger 调试器</p><p>decay 退化</p><p>declaration 声明</p><p>deconstruction 解构</p><p>deduction 推导</p><p>default 缺省、默认值</p><p>defer 推迟</p><p>definition 定义</p><p>delegate/delegation 委托</p><p>deploy 部署</p><p>derived 派生</p><p>design pattern 设计模式</p><p>destructuring 解构</p><p>dialog 对话框</p><p>digest 摘要</p><p>digital 数字的</p><p>directory 目录</p><p>disk 盘</p><p>dispatch 调度、分派、派发</p><p>document 文档</p><p>driver 驱动</p><p>dump 转储</p><p>dynamic binding 动态绑定</p><p>dynamic scope 动态作用域</p><p>dynamic type 动态类型</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>efficiency 效率</p><p>encapsulation 封装</p><p>engine 引擎</p><p>entity 实体</p><p>enum(enumeration) 枚举</p><p>equal 相等</p><p>escape character 转义符</p><p>evaluate 评估</p><p>event 事件</p><p>event driven 事件驱动</p><p>evidence 证据</p><p>excaption 异常</p><p>exception handling 异常处理</p><p>exit 退出</p><p>expendable 可扩展的</p><p>explicit 显式</p><p>export 导出</p><p>extensibility 可扩展性</p><p>extent 范围、程度</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>feature 特征、特性、功能</p><p>fetch 提取</p><p>field 字段</p><p>file 文件</p><p>filter 筛选</p><p>finalization 终结</p><p>firewall 防火墙</p><p>flag 标记</p><p>flush 刷新</p><p>form 窗体</p><p>formal parameter 形参</p><p>forward 转发</p><p>forward declaration 前置声明</p><p>framework 框架</p><p>function 函数</p><h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>GC(Garbage collection) 垃圾回收机制</p><p>generate 生成</p><p>generic 泛化的、一般的、通用的</p><p>genericity 泛型</p><p>global 全局的</p><p>global declaration 全局声明</p><p>grant 授权</p><p>group 组、群</p><p>graphical user interface, GUI 图形用户界面</p><p>GUID(Globally Unique Identifier) 全球唯一标识符</p><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>hack 破解</p><p>handle 处理器、处理程序</p><p>hash tables 哈希表</p><p>heap 堆</p><p>hyperlink 超链接</p><p>HyperText Markup Language, HTML 超文本标记语言</p><p>HyperText Transfer Protocol, HTTP 超文本传输协议</p><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>implement 实现</p><p>implicit 隐式</p><p>import 导入</p><p>indent 缩进</p><p>infinite loop 无线循环</p><p>inheritance 继承</p><p>initialize 初始化</p><p>inline 内联</p><p>instances 实例</p><p>integrate 集成</p><p>interacts 交互</p><p>interface 接口</p><p>interpret 解释</p><p>invoke 调用</p><p>iterate 迭代</p><h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>justify 两端对齐</p><h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>keywords 关键字</p><h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>lexical 词法的</p><p>lexical scope 词法作用域</p><p>library 库</p><p>list 列表</p><p>literal 字面</p><p>load 加载</p><p>local 局部的</p><p>local variable 局部变量</p><h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>macro 宏</p><p>memory 内存</p><p>memory leaks 内存泄漏</p><p>micro 微</p><p>middleware 中间件</p><p>model 模型</p><p>modifier 修饰符</p><p>module 模块</p><p>mutable 可变的</p><h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><p>namespace 命名空间</p><p>native 本地的</p><p>nested 嵌套</p><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>object 对象</p><p>object-oriented 面向对象</p><p>object-oriented programming 面向对象编程</p><p>operating system, OS 操作系统</p><p>operation 操作、操作行为</p><p>operator 运算子、操作符</p><p>optimization 优化</p><p>option 选项</p><p>ordinary 常规的</p><p>orthogonality 正交性</p><p>overflow 溢出</p><p>overload 重载</p><p>override 改写、覆写</p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>package 包</p><p>palette 调色盘、组件盘、工具箱</p><p>parallel 平行、并行</p><p>parameter 参数</p><p>parent class 父类</p><p>parentheses 括号</p><p>parse 解析</p><p>parser 解析器</p><p>pass by address 传址、按址传递</p><p>pass by reference 传引用、按引用传递</p><p>pass by value 传值、按值传递</p><p>pattern 模式</p><p>performance 性能</p><p>pixel 像素</p><p>placeholder 占位符</p><p>pointer 指标、指针</p><p>polymorphism 多态</p><p>primitive type 原生类型</p><p>priority 优先级</p><p>procedure 过程</p><p>profile 评测</p><p>property 属性</p><p>protocol 协议</p><p>prototype 原型</p><p>pseudo code 伪码</p><h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><p>qualified 修饰的</p><p>qualifier 修饰符</p><p>query 查询</p><p>queue 队列</p><p>quote 引用</p><h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><p>radian 弧度</p><p>radio button 圆钮、单选按钮</p><p>random number 随机数</p><p>recursion 递归</p><p>refactor 重构</p><p>reference 引用</p><p>register 寄存器</p><p>regular expression 正则表达式</p><p>represent 表现</p><p>request 请求</p><p>resolve 解析</p><p>resolution 解析度</p><p>routine 例程</p><p>routing 路由</p><h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><p>save 储存</p><p>scaffold 脚手架</p><p>scope 作用域</p><p>scripting language 脚本语言</p><p>semantics 语义</p><p>semicolon 分号</p><p>sequence 序列</p><p>server 服务器</p><p>stack 栈</p><p>statement 语句、陈述</p><p>static type 静态类型</p><p>status 状态</p><p>superclass 基类</p><p>superfluous 多余的</p><p>symbol 符号</p><p>syntax 语法</p><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>table 表格</p><p>tag 标签</p><p>target 目标</p><p>template 模版</p><p>thread 线程</p><p>throw 抛出</p><p>traverse 遍历</p><p>trigger 触发器</p><p>type 类型</p><h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><p>user interface, UI 用户界面</p><p>unqualfied 未修饰的</p><p>uptime 运行时间</p><p>Uniform Resource Locator, URL 统一资源定位符</p><h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><p>validate 验证</p><p>variable 变量</p><p>view 视图</p><p>virtual machine 虚拟机</p><p>virtual memory 虚内存</p><h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><p>warning message 警告信息</p><p>wildcard 通配符</p><p>window 窗口</p><p>wrapper 包装器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;掌握前端开发过程中常用的英语词汇还是非常有必要的，现整理出一些前端英语词汇，希望对从事前端的你有所帮助。&lt;/p&gt;
&lt;h2 id=&quot;前端常用英语词汇表&quot;&gt;&lt;a href=&quot;#前端常用英语词汇表&quot; class=&quot;headerlink&quot; title=&quot;前端常用英语词汇表&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="前端相关" scheme="https://me.miqilin21.cn/categories/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="英语术语" scheme="https://me.miqilin21.cn/tags/%E8%8B%B1%E8%AF%AD%E6%9C%AF%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>使用GitHub+jsDelivr+PicGo搭建免费快速图床</title>
    <link href="https://me.miqilin21.cn/2021/09/28/%E4%BD%BF%E7%94%A8GitHub%E3%80%81jsDelivr%E3%80%81PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%BF%AB%E9%80%9F%E5%9B%BE%E5%BA%8A/"/>
    <id>https://me.miqilin21.cn/2021/09/28/%E4%BD%BF%E7%94%A8GitHub%E3%80%81jsDelivr%E3%80%81PicGo%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%BF%AB%E9%80%9F%E5%9B%BE%E5%BA%8A/</id>
    <published>2021-09-27T16:00:00.000Z</published>
    <updated>2021-12-16T03:05:25.956Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>1.相信不少朋友写 markdown 博客时，想插入一些图片，会采用本地存储方式，需要手动设置路径并把图片上传，这样稍显麻烦，所以可以考虑将图片上传至图床生成 URL，直接在 markdown 引入 url。</p><p>2.可是呢，现在国内用的各种图床，例如：微博图床、Imgur、七牛云、又拍云、腾讯云 COS、阿里云 OSS 等都有各种限制，不是收费就是出了防外链。免费的也有 SM.MS，不过假如哪天需要收费或者关闭服务了，Blog 上的图片只能 GG 了。</p><p>3.使用 GitHub 仓库创建一个图床，存在的问题是国内访问 github 的速度不是很快，可以利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案）。jsDelivr 是首个「打通中国大陆与海外的免费 CDN 服务」，网页开发者无须担心中国防火墙问题而影响体验。</p><h3 id="实际搭建"><a href="#实际搭建" class="headerlink" title="实际搭建"></a>实际搭建</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>首先得在<code>GitHub</code>创建一个<strong>存放图片</strong>的仓库，这个无须多言。不会的<a href="https://wiki.jikexueyuan.com/project/github-basics/creat-new-repo.html">点此链接</a>查看如何创建。</p><h4 id="获取-token"><a href="#获取-token" class="headerlink" title="获取 token"></a>获取 token</h4><p>① 访问<a href="https://github.com/settings/tokens%EF%BC%8C%E7%82%B9%E5%87%BB%60Generate">https://github.com/settings/tokens，点击`Generate</a> new token`按钮。</p><p><img src="/images/jsdelivr/1.jpg"></p><p>② 填入<code>Note</code>，这里就叫 PicGo 好了，并勾选<code>repo</code> 。</p><p><img src="/images/jsdelivr/2.jpg"></p><p>③ 滚动到最下面点击<code>Generate token</code>。</p><p><img src="/images/jsdelivr/3.jpg"></p><p>④ 然后就将生成的<code>token</code>复制下来，后面在<code>PicGo</code>配置的时候会用到。</p><p><img src="/images/jsdelivr/4.jpg"></p><blockquote><p>如果没有复制就离开了此页面，是需要再生成一次的。进入之前输入的<code>Note</code>中会有一个<code>Regenerate token</code>，重新再点击生成一次即可。</p></blockquote><h4 id="配置-PicGo"><a href="#配置-PicGo" class="headerlink" title="配置 PicGo"></a>配置 PicGo</h4><p>① 首先下载安装<code>PicGo</code>软件，Mac 与 Win 都支持。下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>② 然后打开<code>PicGo</code>，进入到<code>图床设置</code>-&gt;<code>github图床</code>进行如下配置：</p><p><img src="/images/jsdelivr/5.jpg"></p><p>这里需要注意一下：</p><ul><li>设定仓库名：填写你的仓库名称，格式：用户名/仓库名</li><li>设定分支名：仓库的分支名，一般填写 master 就行</li><li>设定 Token：之前复制下来的 token</li><li>指定存储路径：图片在仓库中的存储路径，img/可自定义名称</li><li>设定自定义域名：访问图片的域名，例：<a href="https://cdn.jsdelivr.net/gh/miqilin21/static@master">https://cdn.jsdelivr.net/gh/miqilin21/static@master</a></li><li>gh:代表 GitHub</li><li>miqilin21/static:用户名/仓库名</li><li>@master:分支名称</li></ul><p>一个完整的图片路径如下，比如存放名为 12jiqiao.jpg 的图片：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>cdn.jsdelivr.net<span class="hljs-regexp">/gh/mi</span>qilin21<span class="hljs-regexp">/static@master/img</span><span class="hljs-regexp">/12jiqiao.jpg</span><br></code></pre></td></tr></table></figure><p>到这里你就可以搞定了，接下来你可以通过 PicGo 方便地上传图片了，它支持拖拽、点击、剪贴板上传，上传到 Github 仓库后，你就可以复制 PicGo 相册里的图片链接啦。</p><p><img src="/images/jsdelivr/6.jpg"></p><p>当然，你也可以通过 Git 命令，将本地图片批量上传到 Github 对应的仓库上，再替换成原文中的图片链接地址，以完成图片迁移的工作。</p><blockquote><p>关于 PicGo 的使用，请参考<a href="https://picgo.github.io/PicGo-Doc/zh/">官方文档</a></p></blockquote><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>整个过程算比较简单，创建 Github 仓库，并获取 token，填入 PicGo 配置，上传图片即可完成。GitHub+jsDelivr+PicGo 搭建的图片有这样的好处：</p><ul><li>在 Github 存储图片，利于博主对于图片的掌控，并且 Github 仓库的容量有 1G 的上限，对个人博客来说绰绰有余。</li><li>使用 jsDelivr 加速静态文件访问，能够优化博客体验。</li><li>使用 PicGo 的原因是因为能够方便地将上传图片到 Github，并直接获取 jsDelivr 的加速后的图片地址。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;1.相信不少朋友写 markdown 博客时，想插入一些图片，会采用本地存储方式，需要手动设置路径并把图片上传，这样稍显麻烦，所以可以考虑将</summary>
      
    
    
    
    <category term="tools" scheme="https://me.miqilin21.cn/categories/tools/"/>
    
    
    <category term="github" scheme="https://me.miqilin21.cn/tags/github/"/>
    
    <category term="图床" scheme="https://me.miqilin21.cn/tags/%E5%9B%BE%E5%BA%8A/"/>
    
    <category term="PicGo" scheme="https://me.miqilin21.cn/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之运行机制（Event Loop）</title>
    <link href="https://me.miqilin21.cn/2021/09/14/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://me.miqilin21.cn/2021/09/14/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-09-13T16:00:00.000Z</published>
    <updated>2021-12-16T03:05:43.472Z</updated>
    
    <content type="html"><![CDATA[<p>有了一定 JavaScript 基础的朋友们一定知道，JS 里有三座大山，分别指：原型与原型链，作用域与闭包，异步。在之前的 JavaScript 系列文章里，我就总结了 JS 前两座（原型、作用域），有兴趣的朋友可以翻阅之前的系列文章，而第三座（异步）也该做一个总结了，这篇文章的目的就是通过了解 JS 执行顺序及机制，来更好地理顺代码中的一些异步操作。</p><h3 id="单线程的问题"><a href="#单线程的问题" class="headerlink" title="单线程的问题"></a>单线程的问题</h3><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事，不像诸如 Java 等多线程语言一样能同时进行多个任务和流程。</p><p>其中 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，叫它<strong>主线程</strong>。</p><p>但是实际上还存在其他的线程。例如：处理 AJAX 请求的线程、处理 DOM 事件的线程、定时器线程、读写文件的线程(例如在 Node.js 中)等等。这些线程可能存在于 JS 引擎之内，也可能存在于 JS 引擎之外，在此我们不做区分。不妨叫它们<strong>工作线程</strong>。</p><p>但因单线程随之<strong>所带来的问题</strong>是，所有任务都需要排队，上一个任务没执行完，下一个任务就会一直等待，会导致任务执行阻塞。具体的例子是：在浏览器中，要向服务器发送 ajax 请求，http 通信有延迟，而且等待返回数据的时间也未知，那线程就无法处理其他任务了，页面可能长时间会无法接受响应。</p><p>另外，<strong>GUI 渲染线程与 JS 引擎线程是互斥的</strong>，当 JavaScript 引擎执行时 GUI 线程会被挂起，直到 JS 程序执行完成，才会接着执行。因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><p>所以 JS 用异步任务 (asynchronous callback) 去解决这些<strong>问题</strong>。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>写基础系列文章的过程中经常能碰到<strong>同步</strong>(Synchronous)与<strong>异步</strong>(Asynchronous)的概念，这也是初学 JavaScript 时容易搞混的特性之一。</p><p>两者容易搞混我觉得很大的原因出在 Synchronous 在国内被翻译成了「<strong>同步</strong>」，光看字面意思会认为「<strong>同步</strong>」就是「所有动作同时进行」，但事实上<strong>刚好相反</strong>。</p><p>要快速理解同步异步 ， 直接先看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);<br><br><span class="hljs-comment">/*打印出</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这段代码的实现就叫做<strong>同步</strong>，也就是说按照顺序一步一步来处理，做完第一件事情之后，再去做下一件事情。</p><p>再来看另一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);<br><br><span class="hljs-comment">/*打印出</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这段代码的实现就叫做<strong>异步</strong>，也就是说不完全按照顺序去做，如果在函数 A 返回的时候，调用者还不能够得到预期结果，而是需要通过一定的手段等待一段时间去得到，这样也就不耽搁时间。</p><p>所以说 JavaScript 的同步代码比较好理解，而其优势之一是其如何处理异步代码。异步代码会被放入一个事件队列（下面会讲到），等到所有其他代码执行后才进行，而不会阻塞线程，接下来将重点介绍<strong>异步</strong>。</p><h3 id="异步过程是如何形成的？"><a href="#异步过程是如何形成的？" class="headerlink" title="异步过程是如何形成的？"></a>异步过程是如何形成的？</h3><p>简单的总结一下，一个异步过程通常是这样的：</p><ol><li>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；</li><li>主线程可以继续执行后面的代码，同时工作线程执行异步任务；</li><li>工作线程完成工作后，通知主线程；</li><li>主线程收到通知后，执行一定的动作(调用回调函数)。</li></ol><p>异步函数通常具有以下的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">A(argus..., callbackFn)<br></code></pre></td></tr></table></figure><p>其中，函数 A 可以叫做异步过程的发起函数，也叫做异步任务注册函数。<code>argus</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p><p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p><ul><li>发起函数(或叫注册函数)<code>A</code></li><li>回调函数<code>callbackFn</code></li></ul><p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p><p>举一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>其中的<code>setTimeout</code>就是异步过程的发起函数，<code>fn</code>是回调函数。</p><p>注意：前面说的形式<code>A(argus..., callbackFn)</code>只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> request = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>request.open(<span class="hljs-string">&quot;GET&quot;</span>, url);<br>request.send(); <span class="hljs-comment">// 发起函数</span><br>request.onreadystatechange = xxx; <span class="hljs-comment">// 添加回调函数</span><br></code></pre></td></tr></table></figure><p>这种形式的发起函数和回调函数就是分离的。</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>上面提到了异步任务完成后，会通知主线程，以 <code>callback</code> 的方式获取结果或者执行回调。但是如果当前的主线程是忙碌的，异步任务的信号无法接收到怎么办呢？所以还需要一个地方保存这些 <code>callback</code>，也就是<strong>任务队列（task queue）</strong>。</p><p>那么这里就要具体提提 JavaScript 异步执行的<strong>运行机制</strong>了，先用一张图来表现整个过程：</p><p><img src="/images/eventloop/1.jpg"></p><p>上图的完整过程就是：所有同步任务都在主线程上执行，形成一个执行栈，当执行栈遇到异步任务时（浏览器通常是调用 WebAPIs，常见的有 <code>XMLHttpRequest</code>，<code>setTimeout</code>，事件回调等），不会等待，而是继续执行往下执行。而异步任务就会以各种方式，把 <code>callback</code> 加入任务队列中。一旦执行栈中的所有同步任务执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个 <code>callback</code> 任务放入到栈中执行。结束后栈内被清空，还会再去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，而这种循环的机制，就称之为<strong>事件循环</strong>（Event Loop）。</p><h3 id="Event-Loop-事件循环"><a href="#Event-Loop-事件循环" class="headerlink" title="Event Loop(事件循环)"></a>Event Loop(事件循环)</h3><p>事件循环可不是像上面一样一句两句就能讲清的，并且暂时不讨论 node.js 的 Event Loop 执行机制，以下关于浏览器的 Event Loop 执行机制，那在完全了解 Event Loop 之前，还需了解一下宏任务与微任务，因为任务队列又分为<code>macrotask</code>（宏任务）与<code>microtask</code>（微任务），在 ES2015 中 <code>macrotask</code> 即指 Task，而 <code>microtask</code> 则是指代 Job。</p><ul><li>宏任务大概包括：<code>script</code>(整体代码), <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>（Nodejs 环境）, <code>I/O</code>, <code>UI rendering</code>。</li><li>微任务大概包括: <code>process.nextTick</code>（Nodejs 环境）, <code>Promise</code>, <code>Object.observe</code>(已废弃), <code>MutationObserver</code>(html5 新特性)。</li></ul><p>关于<code>macrotask</code>和<code>microtask</code>的理解，得结合事件循坏的机制，下面这张图就可以说是介绍得很清楚了。</p><p><img src="/images/eventloop/2.jpg"></p><p>事件循环的顺序，决定了 JavaScript 代码的执行顺序，一次事件循环的步骤简单总结起来就是：</p><ol><li>检查<code>macrotask</code>队列是否为空，非空则到步骤 2，为空则到步骤 3；</li><li>执行<code>macrotask</code>中的一个任务；</li><li>继续检查<code>microtask</code>队列是否为空，非空则到步骤 4，否则到步骤 5；</li><li>取出<code>microtask</code>中的任务执行，执行完成返回到步骤 3；</li><li>检查是否需要进行视图更新，需要则进行更新，否则进行下一轮的事件循环；</li></ol><p>上面这么多文字表述是不是有点晦涩难懂，那我们通过 2 个 demo 例子来逐步理解<strong>事件循环</strong>的具体顺序吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//demo1</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//setTimeout1</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">//setTimeout2</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br>&#125;);<br><br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);<br>&#125;);<br><br><span class="hljs-comment">// 1，5，2，3，4</span><br></code></pre></td></tr></table></figure><p>我们来说明一下, JS 引擎是如何执行这段代码的：</p><ol><li>主线程上遇到<code>console.log(1)</code>同步代码，执行，输出’1’。</li><li>接着遇到<code>setTimeout1</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在<strong>下</strong>一次的事件循环中执行)。</li><li>接着遇到<code>setTimeout2</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在<strong>下下</strong>一次的事件循环中执行)。</li><li>首先检查微任务队列, 即 <code>microtask</code>队列，发现此队列不为空，执行第一个<code>promise</code>的<code>then</code>回调，输出 ‘5’。</li><li>此时<code>microtask</code>队列为空，进入下一个事件循环, 检查宏任务队列，发现有 <code>setTimeout1</code>的回调函数，立即执行回调函数输出 ‘2’,检查<code>microtask</code> 队列，发现队列不为空，执行<code>promise</code>的<code>then</code>回调，输出’3’，<code>microtask</code>队列为空，进入下一个事件循环。</li><li>检查宏任务队列，发现有 <code>setTimeout2</code>的回调函数, 立即执行回调函数输出’4’。</li></ol><p>再思考一下下面代码的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//demo2</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">//setTimeout1</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">//setTimeout2</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>  <span class="hljs-comment">//setTimeout3</span><br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br>  &#125;);<br>  <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);<br>  &#125;);<br>&#125;, <span class="hljs-number">200</span>);<br><br><span class="hljs-comment">//Promise1</span><br><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>);<br>  &#125;);<br><br><span class="hljs-comment">//Promise2</span><br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">9</span>);<br><br><span class="hljs-comment">// 1，9，6，8，7，2，3，5，4</span><br></code></pre></td></tr></table></figure><p>我们来说明一下, JS 引擎是如何执行这段代码的：</p><ol><li>首先顺序执行完主进程上的同步任务，第一句和最后一句的<code>console.log</code>。</li><li>接着遇到<code>setTimeout1</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在<strong>下</strong>一次的事件循环中执行)；</li><li>接着遇到<code>setTimeout2</code>，它的作用是在 200ms 后将回调函数放到宏任务队列中(这个任务在<strong>下下</strong>一次的事件循环中执行)；</li><li>同步任务执行完之后，首先检查微任务队列, 即 <code>microtask</code>队列，发现此队列不为空，执行第一个<code>promise</code>的<code>then</code>回调，输出 ‘6’，然后执行第二个<code>promise</code>的<code>then</code>回调，输出’8’，由于第一个<code>promise</code>的<code>.then()</code>的返回依然是<code>promise</code>，所以第二个<code>.then()</code>会放到<code>microtask</code>队列继续执行，输出 ‘7’;</li><li>此时<code>microtask</code>队列为空，进入下一个事件循环, 检查宏任务队列，发现有 <code>setTimeout1</code> 的回调函数，立即执行回调函数输出 ‘2’,检查<code>microtask</code> 队列，队列为空，进入下一次事件循环；</li><li>检查宏任务队列，发现有 <code>setTimeout2</code> 的回调函数, 立即执行回调函数输出’3’；</li><li>接着遇到<code>setTimeout3</code>，它的作用是在 0ms 后将回调函数放到宏任务队列中(这个任务在下一次的事件循环中执行)，检查微任务队列，即 <code>microtask</code> 队列，发现此队列不为空，执行<code>promise</code>的<code>then</code>回调，输出’5’；</li><li>此时<code>microtask</code>队列为空，进入下一个事件循环，检查宏任务队列，发现有 <code>setTimeout3</code> 的回调函数，立即执行回调函数输出，输出’4’。至此代码执行结束。</li></ol><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>这里再补一道面试题，如何执行这段代码的过程就不详细说明了，朋友们自行去体会：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;1&quot;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;2&quot;</span>);<br>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;3&quot;</span>);<br>  &#125;);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;4&quot;</span>);<br>    resolve();<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;5&quot;</span>);<br>  &#125;);<br>&#125;);<br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;6&quot;</span>);<br>&#125;);<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;7&quot;</span>);<br>  resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;8&quot;</span>);<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;9&quot;</span>);<br>  process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;10&quot;</span>);<br>  &#125;);<br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;11&quot;</span>);<br>    resolve();<br>  &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;12&quot;</span>);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// 1，7，6，8，2，4，3，5，9，11，10，12</span><br><span class="hljs-comment">// node环境下的事件监听依赖libuv驱动I/O库与前端环境不完全相同，输出顺序可能会有误差</span><br></code></pre></td></tr></table></figure><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><ul><li><a href="https://blog.csdn.net/leftfist/article/details/41891407">Node.js 机制及原理理解初步</a></li><li><a href="http://lynnelv.github.io/js-event-loop-nodejs">深入理解 js 事件循环机制（Node.js 篇）</a></li></ul><p>后续自己也会追加一篇关于 Node.js 的事件循环机制的文章。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有了一定 JavaScript 基础的朋友们一定知道，JS 里有三座大山，分别指：原型与原型链，作用域与闭包，异步。在之前的 JavaScript 系列文章里，我就总结了 JS 前两座（原型、作用域），有兴趣的朋友可以翻阅之前的系列文章，而第三座（异步）也该做一个总结了，这</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="运行机制" scheme="https://me.miqilin21.cn/tags/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    
    <category term="Event Loop" scheme="https://me.miqilin21.cn/tags/Event-Loop/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之深入理解对象属性</title>
    <link href="https://me.miqilin21.cn/2021/08/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/"/>
    <id>https://me.miqilin21.cn/2021/08/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7/</id>
    <published>2021-08-12T16:00:00.000Z</published>
    <updated>2021-12-16T03:05:55.809Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://zhuanlan.zhihu.com/p/64928794">《谈谈 JavaScript 中对象建立(Object)》</a>这一文中，我们曾经简单地介绍过对象及其创建方式。在今天这一篇文章当中呢，我们要更深入地来理解 JavaScript 的对象与其他编程语言的对象有何差异。</p><p>开始介绍之前先来复习一下。</p><p>之前说过，所有原始类型(Primitives) 以外的值都是对象，原始类型有以下几种：</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li><li><code>symbol</code> (ES6 新增)</li></ul><p>除了上述这些以外的类型，都是对象。</p><h3 id="JavaScript-真是一门面向对象的编程语言吗？"><a href="#JavaScript-真是一门面向对象的编程语言吗？" class="headerlink" title="JavaScript 真是一门面向对象的编程语言吗？"></a>JavaScript 真是一门面向对象的编程语言吗？</h3><p>在过去 JS 语言的发展中，这个话题已经被讨论过无数次，有人说它是，也有人说它不那么像是。就像一个使用 Java 或 C#或者其他面向对象开发语言的开发者接触 JavaScript 的时候，他总会抱怨 JavaScript 太混乱、没有类型、结构也不好，还有很多奇奇怪怪的地方，它的对象支持也是微乎其微，因此他绝对不是一个面向对象编程的语言。</p><p>但 JavaScript 确实是一门面向对象的编程语言，只是它与其他语言很大不同的地方是，它的继承方法是通过”prototype” 来实现的。其余大多数的面向对象的编程语言（比如 Java）是以「类」为基础的(<code>class-based</code>) ，但 JavaScript 没有<code>class</code>、没有<code>extends</code> ，却可以通过「原型」(<code>prototype-based</code>) 来建立起对象之间的继承关系。</p><p>PS：ES6 虽然新增了<code>class</code>语法，但仍然属于<code>prototype-based</code>的继承。<code>class</code>实质上只是通过简洁的语法来建立对象和处理继承的语法糖。</p><h3 id="JavaScript-自定义对象"><a href="#JavaScript-自定义对象" class="headerlink" title="JavaScript 自定义对象"></a>JavaScript 自定义对象</h3><p>先前曾介绍过，在 JavaScript 创建对象我们可以通过<code>new</code>关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>person.name = <span class="hljs-string">&quot;mike&quot;</span>;<br></code></pre></td></tr></table></figure><p>或是直接用大括号<code>&#123; &#125;</code>，即可创建起一个新的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  name: <span class="hljs-string">&quot;mike&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="理解-JavaScript-构造函数"><a href="#理解-JavaScript-构造函数" class="headerlink" title="理解 JavaScript 构造函数"></a>理解 JavaScript 构造函数</h3><p>虽然 JavaScript 没有<code>class</code>的语法，但如果你希望 JavaScript 也能像其他面向对象编程语言一样有类似<code>class</code>的语法时，可以怎么做呢？由于函数也是个对象，所以可以借用来当作「构造函数」来建立其他对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, gender</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.age = age;<br>  <span class="hljs-built_in">this</span>.gender = gender;<br><br>  <span class="hljs-built_in">this</span>.greeting = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello! My name is &quot;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&quot;.&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> mike = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&quot;male&quot;</span>);<br>mike.greeting(); <span class="hljs-comment">// &quot;Hello! My name is Mike.&quot;</span><br><br><span class="hljs-keyword">var</span> jay = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;male&quot;</span>);<br>jay.greeting(); <span class="hljs-comment">// &quot;Hello! My name is Jay.&quot;</span><br></code></pre></td></tr></table></figure><p>像这样，我们建立了一个<code>Person</code>构造函数(Constructor) ，然后就可以通过<code>new</code>关键字来建立各种对应的对象。</p><p>为什么 JavaScript 明明没有<code>class</code>却可以通过<code>new</code>一个函数来建立对象？这里简单拆解一下流程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, gender</span>) </span>&#123;<br>  <span class="hljs-comment">// 和上面一致，这里省略</span><br>&#125;<br><br><span class="hljs-keyword">var</span> mike = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&quot;male&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">===&gt; var mike = &#123;&#125;;</span><br><span class="hljs-comment">===&gt; Person.call(mike, &#x27;Mike&#x27;, 28, &#x27;male&#x27;);</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>通过<code>new Person(...)</code>这个动作，返回的对象会有<code>name</code>, <code>age</code>, <code>gender</code>以及<code>greeting</code>属性，而 JavaScript 会在背景执行<code>Person.call</code>方法，将<code>mike</code>作为<code>this</code>的参考对象，然后把这些属性通通新增到<code>mike</code>对象中。</p><p>但是，即使是通过构造函数（Constructor）建立的对象，这个对象的属性仍然可以通过<code>.</code>来公开存取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, gender</span>) </span>&#123;<br>  <span class="hljs-comment">// 和上面一致，这里省略</span><br>&#125;<br><br><span class="hljs-keyword">var</span> mike = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-number">28</span>, <span class="hljs-string">&quot;male&quot;</span>);<br><span class="hljs-built_in">console</span>.log(mike.age); <span class="hljs-comment">// 32</span><br><br><span class="hljs-comment">// 因为是公开属性，所以可以很无耻地开放修改</span><br>mike.age = <span class="hljs-number">18</span>;<br><br><span class="hljs-built_in">console</span>.log(mike.age); <span class="hljs-comment">// 18</span><br></code></pre></td></tr></table></figure><h3 id="属性描述符-Property-descriptor"><a href="#属性描述符-Property-descriptor" class="headerlink" title="属性描述符(Property descriptor)"></a>属性描述符(Property descriptor)</h3><p>从 ES5 开始，我们可以通过新的对象模型来控制对象属性的存取、删除、列举等功能。这些特殊的属性，我们将它称为「<strong>属性描述符</strong>」（Property descriptor）。</p><p><strong>属性描述符</strong>一共可以分为六种：</p><ol><li><code>value</code>: 属性的值</li><li><code>writable</code>:定义属性是否可以改变，如果是<code>false</code>那就是只可读属性。</li><li><code>enumerable</code>:定义对象内的属性是否可以通过<code>for-in</code>语法来迭代。</li><li><code>configurable</code>:定义属性是否可以被删除、或修改属性内的<code>writable</code>、<code>enumerable</code>及<code>configurable</code>设定。</li><li><code>get</code>: 对象属性的 getter function。</li><li><code>set</code>: 对象属性的 setter function。</li></ol><p>上述除了<code>value</code>之外的值都可以不设定，<code>writable</code>、<code>enumerable</code>及<code>configurable</code>的默认值是<code>false</code>，而<code>get</code>与<code>set</code>如果没有特别指定则是<code>undefined</code>，并且前四种属性不能和<code>get</code>与<code>set</code>混用，否则会抛出错误。</p><p>这些「属性描述符」必须要通过 ES5 所提供的<code>Object.defineProperty()</code>来处理。</p><h3 id="Object-defineProperty-与-Object-getOwnPropertyDescriptor"><a href="#Object-defineProperty-与-Object-getOwnPropertyDescriptor" class="headerlink" title="Object.defineProperty 与 Object.getOwnPropertyDescriptor"></a>Object.defineProperty 与 Object.getOwnPropertyDescriptor</h3><p>我们可以通过<code>Object.defineProperty</code>来定义对象的属性描述，用法：<code>Object.defineProperty(obj, prop, descriptor)</code>。</p><p>其中：<code>obj</code>-&gt;要在其上定义属性的对象；<code>prop</code>-&gt;要定义或修改的属性的名称；<code>descriptor</code>-&gt;将被定义或修改的属性描述符。</p><p>下面通过实际范例来解释：</p><p>一般来说，要建立一个简单对象，我们可以用这样方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  name: <span class="hljs-string">&quot;mike&quot;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当然，我们也可以通过<code>Object.defineProperty</code>来定义对象<code>person</code>的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  value: <span class="hljs-string">&quot;mike&quot;</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样的方式与直接指定对象字面属性是一样的结果。</p><p>然后，我们可以用<code>Object.getOwnPropertyDescriptor()</code>来检查对象属性描述器的状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  value: <span class="hljs-string">&quot;mike&quot;</span>,<br>&#125;);<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="/images/object2/1.jpg"></p><p>可以看到在默认的情况下，<code>writable</code>、<code>enumerable</code>及<code>configurable</code>都是<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person2 = &#123;<br>  name: <span class="hljs-string">&quot;mike&quot;</span>,<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(person2, <span class="hljs-string">&quot;name&quot;</span>));<br></code></pre></td></tr></table></figure><p><img src="/images/object2/2.jpg"></p><p>而通过字面式创建对象建立的属性，默认值则会是<code>true</code>。</p><p><code>defineProperty</code>可以针对对象一次设定多个属性描述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  value: <span class="hljs-string">&quot;mike&quot;</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">false</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>或是分别设定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  enumerable: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这些都是合法的做法。</p><p>假设我们已经定义<code>person.name</code>属性描述<code>configurable</code>为<code>false</code>的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  value: <span class="hljs-string">&quot;mike&quot;</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">false</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p>那么此时，我们再去执行删除属性的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> person.name; <span class="hljs-comment">// it will return false</span><br></code></pre></td></tr></table></figure><p>虽然不会出错，但是你会发现执行结果会返回<code>false</code>，且<code>person</code>对象的<code>name</code>属性依然存在。同样地，当<code>writable</code>为<code>true</code>时，你去尝试删除属性「值」的时候，你会发现结果是无效的。</p><p>要注意的是，上面这些行为，若是在「严格模式」下则会发生<code>TypeError</code>的错误。</p><h3 id="属性的-get-与-set-方法"><a href="#属性的-get-与-set-方法" class="headerlink" title="属性的 get 与 set 方法"></a>属性的 get 与 set 方法</h3><p>在本文的开始，我们介绍了早期在 ES5 以前通过<code>this.getXXX()</code>与<code>this.setXXX()</code>来作为<code>get</code>与<code>set</code>的存取方法。</p><p>而现在 ES5 提供了<code>Object.defineProperty()</code>之后，我们可以更直观地来处理这些方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(person, <span class="hljs-string">&quot;name&quot;</span>, &#123;<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;get&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name_;<br>  &#125;,<br>  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;set&quot;</span>);<br>    <span class="hljs-built_in">this</span>._name_ = name;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>像这样，我们可以分别为<code>name</code>属性去定义<code>get</code>与<code>set</code>方法，而实际上，我们是通过了另一个属性<code>_name_</code>来作为<code>name</code>属性的封装。要注意的是，如果你定义了<code>get</code>与<code>set</code>方法，表示你要自行控制属性的存取，那么就不能再去定义<code>value</code>或<code>writable</code>的属性描述。</p><p>理解了 ES5 的对象属性描述符之后，往后我们在对对象的属性处理就可以更加灵活，像是 VueJS 也是通过 Object.defineProperty 的 get 与 set 来做到双向数据绑定的：</p><p><img src="/images/object2/3.jpg"></p><p>每个组件实例都对应一个<strong>watcher</strong>实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 <code>setter</code> 触发时，会通知 <code>watcher</code>，从而使它关联的组件重新渲染。</p><p>图片来源：<a href="https://cn.vuejs.org/v2/guide/reactivity.html">Vue.js: 如何追踪变化</a></p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64928794&quot;&gt;《谈谈 JavaScript 中对象建立(Object)》&lt;/a&gt;这一文中，我们曾经简单地介绍过对象及其创建方式。在今天这一篇文章当中呢，我们要更深入地来理解 JavaScri</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="对象" scheme="https://me.miqilin21.cn/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的工具、网站</title>
    <link href="https://me.miqilin21.cn/2021/07/23/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99/"/>
    <id>https://me.miqilin21.cn/2021/07/23/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E3%80%81%E7%BD%91%E7%AB%99/</id>
    <published>2021-07-22T16:00:00.000Z</published>
    <updated>2021-12-16T03:06:09.790Z</updated>
    
    <content type="html"><![CDATA[<p>这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下 13 款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。</p><h4 id="Evernote：一款神奇的笔记"><a href="#Evernote：一款神奇的笔记" class="headerlink" title="Evernote：一款神奇的笔记"></a>Evernote：一款神奇的笔记</h4><p>✔ 如果一款工具能满足你对笔记的所有需求的话，那就是 Evernote 了，写笔记，列清单，时间管理，录音，工作同步，手机和电脑端都可下载…</p><p>✔ 如果你还没用过，推荐你现在关闭答案去应用市场下载一个，相信我你都会爱上它的。</p><p><img src="/images/tool/1.jpg"></p><h4 id="免费人工智能-PPT-制作平台：beautiful-ai"><a href="#免费人工智能-PPT-制作平台：beautiful-ai" class="headerlink" title="免费人工智能 PPT 制作平台：beautiful.ai"></a>免费人工智能 PPT 制作平台：<a href="https://www.beautiful.ai/">beautiful.ai</a></h4><p>✔ 这个国外的黑科技网站，网站提供很多超赞的板式，我们将文字放进去，AI 智能帮助我们制作 PPT。真的让我这个一做 PPT 就头疼的人，感到开心！</p><p>✔ 没广告还免费！</p><p><img src="/images/tool/2.jpg"></p><h4 id="录制-GIF-工具-：GifCam"><a href="#录制-GIF-工具-：GifCam" class="headerlink" title="录制 GIF 工具 ：GifCam"></a>录制 GIF 工具 ：GifCam</h4><p>✔ 录制动图对许多人来说也算是必备的东西了。</p><p>✔ 窗口化录屏，也可以直接设置全屏幕录制，录制完毕后直接保存为 GIF 图片，软件大小不超过 2M，简直太方便太良心了~</p><p><img src="/images/tool/3.jpg"></p><h4 id="截图-贴图神器：Snipaste"><a href="#截图-贴图神器：Snipaste" class="headerlink" title="截图/贴图神器：Snipaste"></a>截图/贴图神器：Snipaste</h4><p>✔ 它在我心中绝对可以堪称神器了！令人惊叹不仅仅是它的强大截图功能，而是它的贴图功能也实在是太好用了！</p><p><img src="/images/tool/4.jpg"></p><h4 id="设计网址导航网站：牛大拿"><a href="#设计网址导航网站：牛大拿" class="headerlink" title="设计网址导航网站：牛大拿"></a>设计网址导航网站：<a href="http://www.niudana.com/">牛大拿</a></h4><p>✔ 精选国内外优秀的 UI 设计网站,设计参考文章与免费的 UI 设计素材与资源，每日更新 Dribbble 精选内容、Behance 精选内容、站酷精选内容、UI 中国…</p><p>✔ 一定也有设计师不知道这个网站滴。</p><p><img src="/images/tool/5.jpg"></p><h4 id="国外设计师常用网站：Dribbble"><a href="#国外设计师常用网站：Dribbble" class="headerlink" title="国外设计师常用网站：Dribbble"></a>国外设计师常用网站：<a href="https://dribbble.com/">Dribbble</a></h4><p>✔ 通过 Dribbble，你可以浏览许多创意设计，它们出自世界各地的个人设计师、设计团队以及设计公司。</p><p>✔ 这些作品并不仅限于网页或手机 app 设计，还有图片设计、品牌设计、动画、插图、平面艺术等等。</p><p><img src="/images/tool/6.jpg"></p><h4 id="国内设计师常用网站：花瓣网"><a href="#国内设计师常用网站：花瓣网" class="headerlink" title="国内设计师常用网站：花瓣网"></a>国内设计师常用网站：花瓣网</h4><p>✔ 花瓣网算是一个国内比较好的素材采集网，平时想要找的各种类型的图片素材在花瓣都能采集到，比如平面、漫画、摄影、UI 等等。</p><p>✔ 而且花瓣的素材普遍都很有设计感和时尚感，很适合年轻一代做设计。</p><p><img src="/images/tool/7.jpg"></p><h4 id="设计师和开发常用网站：iconfont-cn"><a href="#设计师和开发常用网站：iconfont-cn" class="headerlink" title="设计师和开发常用网站：iconfont.cn"></a>设计师和开发常用网站：<a href="https://www.iconfont.cn/">iconfont.cn</a></h4><p>✔ 阿里巴巴旗下的免费 icon 百科网站，可免费下载矢量源文件，选择时可以打包所有你感兴趣的放在购物车，Download 时还可以选择颜色和大小,很贴心有木有！同时支持下载开发用代码。</p><p>✔ 比如搜索关键词“love”看到的结果：</p><p><img src="/images/tool/8.jpg"></p><h4 id="壁纸天堂：Wallhaven"><a href="#壁纸天堂：Wallhaven" class="headerlink" title="壁纸天堂：Wallhaven"></a>壁纸天堂：<a href="https://alpha.wallhaven.cc/">Wallhaven</a></h4><p>✔ 图片量大而且还高清，分类清晰(人物/风景/动画)。</p><p>✔ 相比一些图库不全，广告遍地，收费下载的壁纸网站，免费下载的 wallhaven 简直就是业界良心。</p><p><img src="/images/tool/9.jpg"></p><h4 id="在线制作流程图网站：ProcessOn"><a href="#在线制作流程图网站：ProcessOn" class="headerlink" title="在线制作流程图网站：ProcessOn"></a>在线制作流程图网站：<a href="https://www.processon.com/">ProcessOn</a></h4><p>✔ProcessOn 在线支持流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。</p><p>✔ 轻松绘制，基本上是 0 难度上手。</p><p><img src="/images/tool/10.jpg"></p><h4 id="在线生成图片链接网站：SM-MS"><a href="#在线生成图片链接网站：SM-MS" class="headerlink" title="在线生成图片链接网站：SM.MS"></a>在线生成图片链接网站：<a href="https://sm.ms/">SM.MS</a></h4><p>✔SM.MS 图床网站只需上传一张本地的图片，点击生成链接即可，操作简单快捷。</p><p>✔ 永久存储免注册，图片链接支持 https，可以删除上传的图片，提供多种图片链接格式。</p><p><img src="/images/tool/11.jpg"></p><h4 id="Listary：电脑文件秒搜-路径直达"><a href="#Listary：电脑文件秒搜-路径直达" class="headerlink" title="Listary：电脑文件秒搜+路径直达"></a>Listary：电脑文件秒搜+路径直达</h4><p>✔ 软件体积非常小，全局本地搜索的便捷工具，设置热键后，能在任何环境下调出窗口搜索文件，如我设置的是’Win+F’，想要找某文件时按下 Win+F 调出小长条搜索框就能进行实时搜索，非常便捷。</p><p>✔ 相信你用了后会觉得它很高效的。</p><p><img src="/images/tool/12.jpg"></p><h4 id="v9porn"><a href="#v9porn" class="headerlink" title="v9porn"></a><a href="https://github.com/techGay/v9porn">v9porn</a></h4><p>✔ 看到上面的标题，想必大多数人都知道了吧嘿嘿嘿</p><p>✔ 那这个项目就不多介绍了，自行体会，体验好的话就默默点个赞哦</p><p><img src="/images/tool/13.jpg"></p><p>本人 Github 链接如下，欢迎各位 Star</p><p><a href="https://github.com/miqilin21/miqilin21.github.io">https://github.com/miqilin21/miqilin21.github.io</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里收集了一些我觉得能堪称神器的工具，能堪称神器的工具的一个关键词就是简单好用，对我们的工作生活要有所帮助，我就推荐一下 13 款我觉得好用的一些工具及网站。最后一个工具嘛~你懂的嘿嘿嘿。&lt;/p&gt;
&lt;h4 id=&quot;Evernote：一款神奇的笔记&quot;&gt;&lt;a href=&quot;#Ev</summary>
      
    
    
    
    <category term="tools" scheme="https://me.miqilin21.cn/categories/tools/"/>
    
    
    <category term="工具" scheme="https://me.miqilin21.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之立即执行函数IIFE</title>
    <link href="https://me.miqilin21.cn/2021/07/17/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0IIFE/"/>
    <id>https://me.miqilin21.cn/2021/07/17/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0IIFE/</id>
    <published>2021-07-16T16:00:00.000Z</published>
    <updated>2021-12-16T03:06:27.616Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们已经介绍了函数的参数，arguments 对象以及回调函数，那么在今天的分享中，我们继续来看看函数在 JavaScript 的另外一种面貌——立即执行函数表达式（Immediately Invoked Functions Expressions，IIFE）。</p><p><strong>IIFE(Immediately Invoked Functions Expressions)**其实可以就字面上直接来理解，Immediately 就是立即的意思，invoked 则是执行某个函数时「执行」的意思，function expression 是一种用来创建函数的方法，</strong>总的来说，就是用函数表达式的方式建立函数后并立即执行它**。</p><p>下面我们将做更进一步的介绍和说明。</p><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>JavaScript 中有两种常见的声明函数的方法，分别是通过<strong>function 命令</strong>或<strong>函数表达式声明</strong>，来看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// function 命令</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hi&quot;</span> + name);<br>&#125;<br>sayHi(<span class="hljs-string">&quot;miqilin&quot;</span>);<br><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">var</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>&#125;;<br>sayHello(<span class="hljs-string">&quot;miqilin&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h3><p>那么什么是<strong>IIFE</strong>呢？如同文章一开始所叙述的，<strong>IIFE 指的就是通过函数表达式的方式来创建函数，并且立即执行它</strong>。那我们要怎么做呢？</p><p>首先我们可以用 console.log 的方式，先来看一下，我们刚刚创建的 sayHello 打印出来会长什么样子呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-keyword">var</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>&#125;;<br><span class="hljs-built_in">console</span>.log(sayHello);<br></code></pre></td></tr></table></figure><p>结果会发现，直接把 sayHello 打印出来后，它会直接返回整个函数的代码内容，这是尚未”执行（Invoked）”代码前的结果。</p><p><img src="/images/IIFE/1.jpg"></p><p>如果是 IIFE 就在这段代码的最后，加上一个执行的指令，也就是括号<code>( )</code>：</p><p><img src="/images/IIFE/2.jpg"></p><p>上图就可以看出，在我们定义函数的同时，这段函数就会立即被执行了，当然最后的<code>( )</code>中可以加入参数：</p><p><img src="/images/IIFE/3.jpg"></p><p>那如果我们把前面的声明变量去了呢，变成一个匿名函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//不可行的做法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> name </span>)  </span>&#123;<br>  <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;Hello &#x27;</span>  + name ) ;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这么做是不可行的，因为 JavaScript 引擎在解析代码的时候，你用<code>function</code>作为开头，引擎会认为你现在要输入<code>function</code> 命令去创建函数，<strong>可是你却没有给该 function 名称，于是它无法正确理解这段代码便抛出错误</strong>：</p><p><img src="/images/IIFE/4.jpg"></p><p>所以，这时候我们要做的是告诉 JavaScript 引擎说，这一整个并不是<code>function</code> 命令。要达到这样的目的，我们要让引擎在解析代码的时候，不是以读到<code>function</code> 作为开头。</p><p>为了要达到这样的目的，我们最常使用的做法就是用括号<code>()</code>将<code>function()&#123; ...&#125;</code>包起来，像是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello &quot;</span> + name);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>因为我们只会在括号内放入表达式，例如(3+2)，而不会放命令在括号内，所以 JavaScript 就会以表达式的方式来读取这段函数。</strong></p><p>在这种情况下，这个函数会被建立，但是不会被存在任何变量当中，也不会被执行。</p><p>结合刚刚上面 IIFE 的概念，我们可以在创建这个函数的同时，将这个函数加以执行，我们同样只需要在最后加上括号<code>()</code>就可以了：</p><p><img src="/images/IIFE/5.jpg"></p><p>这样 IIFE 的型式，会在许多的 JavaScript 框架中都看得到，比如 jQuery，jQuery 用了这样的手法将<code>window</code>与<code>undefined</code>保留起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">window</span>, <span class="hljs-literal">undefined</span></span>) </span>&#123;<br>  <span class="hljs-comment">// 略...</span><br>&#125;)(<span class="hljs-built_in">window</span>);<br></code></pre></td></tr></table></figure><p>其中<code>undefined</code>是可以被修改的，虽然 jQuery 在 IIFE 定义了两个参数，但只传了一个<code>winodw</code>，就是为了保持<code>undefined</code>原本的样子。</p><p><strong>通过这样的方式，我们可以「直接执行某个函数」，一个很重要的一点是，这样做不仅避免了外界访问此 IIFE 内的变量，而且又不会污染全局作用域。</strong></p><h3 id="IIFE-执行过程解析"><a href="#IIFE-执行过程解析" class="headerlink" title="IIFE 执行过程解析"></a>IIFE 执行过程解析</h3><p>先看段 IIFE 实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//IIFE</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(greeting + <span class="hljs-string">&quot; &quot;</span> + name);<br>&#125;)(<span class="hljs-string">&quot;miqilin&quot;</span>);<br></code></pre></td></tr></table></figure><p>让我们看看，当我们在执行这段代码的过程中，JavaScript 引擎实际发生了什么事吧！</p><p>首先，当我执行这段代码时，会先建立全局执行上下文（Global Execution Context），但这时候这个执行上下文里面是没有任何内容的，因为我们并没有在全局这层建立任何变量（如果有的话，变量的名称会先提升在全局上下文中。）</p><p><img src="/images/IIFE/6.jpg"></p><p>接着，JavaScript 引擎会执行到我们所建立的这段 IIFE，它会将这个匿名函数储存在全局执行上下文。</p><p><img src="/images/IIFE/7.jpg"></p><p>由于我们在函数的最后有加上<code>( )</code>，所以这段函数会立即被执行，也因此，JavaScript 会为这个匿名函数建立一个新的执行上下文。</p><p><img src="/images/IIFE/8.jpg"></p><p>接着，它会去逐行执行我们这个函数中的代码内容，它发现到我们的代码中建立了一个变量，名称是”greeting”，因此，这个变量就被建立在函数的这个执行上下文中，而不是被建立在全局上下文中。</p><p><img src="/images/IIFE/9.jpg"></p><p>因此，通过 IIFE，我们可以发现，在 IIFE 中所建立的变量，都不会影响到全局执行上下文所建立的变量，这里再次提一下，通过 IIFE，它避免了我们的变量间可能会互相干扰覆盖的情况。</p><h3 id="IIFE-的实际应用"><a href="#IIFE-的实际应用" class="headerlink" title="IIFE 的实际应用"></a>IIFE 的实际应用</h3><p>让我们先回到上面的代码，这时候我们在函数的外面，声明一个同样的变量名(greeting)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//全局执行上下文</span><br><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hi&quot;</span>;<br><br><span class="hljs-comment">//IIFE</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(greeting + <span class="hljs-string">&quot; &quot;</span> + name);<br>&#125;)(<span class="hljs-string">&quot;miqilin&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(greeting);<br></code></pre></td></tr></table></figure><p>这时候的打印出的顺序为：</p><p><img src="/images/IIFE/10.jpg"></p><p>你会发现，虽然同样都是调用 greeting 这个变量，但是一个是在函数执行上下文内的 greeting，一个是在全局执行上下文的 greeting，两者是不会互相影响的。</p><p>同样把它画成上面一样的图形，它们两个是不同的执行上下文被储存在不同的内存中，所以不会相互影响。</p><p><img src="/images/IIFE/11.jpg"></p><p>如此，我们可以很直观地确定，放在 IIFE 里面的变量，并不会影响到其他外层的变量，也不会被外层的变量影响到。</p><h3 id="如果执意要影响外层变量呢？"><a href="#如果执意要影响外层变量呢？" class="headerlink" title="如果执意要影响外层变量呢？"></a>如果执意要影响外层变量呢？</h3><p>虽然我们使用 IIFE 的主要目的就是希望不同执行上下文之间的变量不要互相影响，但如果我们还是想让函数执行上下文这层的变量能够同时影响到全局执行上下文的变量时，我们可以怎么操作呢？</p><p>首先，我们得多一个参数，叫做 global，在最后带入参数的地方，我们填入对象<code>window</code>，由于我们知道对象是引用类型的特性，因此我们可以直接针对<code>window</code>里面的对象去做改变，像这里，我就可以直接把<code>global</code>层次的对象改成<code>hola</code>（<code>global.greeting = &#39;Hola&#39;</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//全局执行上下文</span><br><span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hi&quot;</span>;<br><br><span class="hljs-comment">//IIFE</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">global</span>, name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> greeting = <span class="hljs-string">&quot;Hello&quot;</span>;<br>  <span class="hljs-built_in">global</span>.greeting = <span class="hljs-string">&quot;Hola&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(greeting + <span class="hljs-string">&quot; &quot;</span> + name);<br>&#125;)(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;miqilin&quot;</span>);<br><br><span class="hljs-built_in">console</span>.log(greeting);<br></code></pre></td></tr></table></figure><p>结果如下，原本在全局执行上下文的<code>Hi</code>，被变换为<code>Hola</code>了：</p><p><img src="/images/IIFE/12.jpg"></p><p>这操作够骚吧！哈哈~</p><h3 id="一道-IIFE-经典面试题"><a href="#一道-IIFE-经典面试题" class="headerlink" title="一道 IIFE 经典面试题"></a>一道 IIFE 经典面试题</h3><p>题目是这样的：假设想通过循环+ setTimeout 来做到，在五秒钟之内，每秒钟依序通过<code>console.log</code>打印出：<code>0 1 2 3 4</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>真的是这样吗？我们来看看执行的结果：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">//过了接近一秒五个五同时打出</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>为什么会这样呢？</p><p>我们知道， JavaScript 是一个「异步」的语言，所以当我们执行这段代码时，<code>for</code>循环并不会等待<code>window.setTimeout</code>结束后才继续，而是在执行阶段就<strong>一口气跑完</strong>。</p><p>也就是说，当<code>window.setTimeout</code>内的回调函数执行时，拿到的<code>i</code>已经是跑完<code>for()</code>循环的<code>5</code>。</p><p><img src="/images/IIFE/13.jpg"></p><p>那么要怎么解决这个问题呢？</p><p>我们可以把<code>window.setTimeout</code>包装成一个 IIFE，这个问题就迎刃而解了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-comment">// 为了凸显差异，我们将传入后的参数改名为 x</span><br>  <span class="hljs-comment">// 当然由于作用域的不同，要继续在内部沿用 i 也是可以的。</span><br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(x);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候你会发现，执行的结果就会是我们预期的<code>0 1 2 3 4</code>了，但还是有一个问题：就是<code>0 1 2 3 4</code>还是在一秒钟后同时出现啊？怎么解决？</p><p>嘿嘿，相信聪明的你已经发现，由于<code>for</code>循环在一瞬间就跑完，等于那一瞬间它向<code>window</code>依序注册了五次 timer，每个 timer 都只等待一秒钟，当然同时出现喽。</p><p>所以我们稍微修改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-comment">// 将原来的 1000 改成 1000 * x</span><br>    <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(x);<br>    &#125;, <span class="hljs-number">1000</span> * x);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样，就可以依序打印出我们想要的结果喽！</p><p>[注] ES6 以后新增了<code>let</code>与<code>const</code>，且改以<code>&#123; &#125;</code>作为它的块级作用域。</p><p>换句话说，将上例中的<code>for</code>改为<code>let</code>就可以做到保留<code>i</code>在执行循环当下的「值」，打出一样的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;, <span class="hljs-number">1000</span> * (i + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再那么必要了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的文章当中，我们已经介绍了函数的参数，arguments 对象以及回调函数，那么在今天的分享中，我们继续来看看函数在 JavaScript 的另外一种面貌——立即执行函数表达式（Immediately Invoked Functions Expressions，IIF</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="IIFE" scheme="https://me.miqilin21.cn/tags/IIFE/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之回调函数</title>
    <link href="https://me.miqilin21.cn/2021/07/10/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>https://me.miqilin21.cn/2021/07/10/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2021-12-16T03:06:37.849Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章当中，我们已经介绍了函数的参数与 arguments 对象，那么今天的分享中，我们继续来看看函数在 JavaScript 的各种不同面貌——回调函数。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>你可能常听到人家在谈论回调函数（Callback function），但你真的知道回调函数是什么吗？其实回调函数跟一般的函数没什么不同，差别只在于被调用执行的时机。</p><p>先前介绍事件的时候有说过，「JavaScript 是一个事件驱动(Event-driven) 的编程语言」，而事件的概念就如同：</p><p><strong>办公室电话响了(事件被触发 Event fired) -&gt; 接电话(处理事件 Event Handler)</strong></p><p>而写成代码形式就类似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 注：这里只是比喻，并没有电话响这个事件</span><br>Office.addEventListener(<span class="hljs-string">&quot;电话响&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> 接电话(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>可以看到，<code>Office</code>通过<code>addEventListener</code>方法去注册了一个事件，当这个事件被触发时，它会去执行我们所指定的第二个参数，也就是某个「函数」(接电话)。</p><p>换句话说，这个函数只会在满足了某个条件才会被动地去执行，我们就可以说这是一个<strong>回调函数</strong>。</p><p>经历过各种「事件」的你，想必也发现了一件事，所谓的回调函数其实就是「<strong>把函数作为参数传递给另一个函数，然后通过另一个函数来调用它</strong>」。</p><p>不知大家有没有听懂？那我再讲一个简单案例吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; ... &#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>如果我们希望隔某段时间之后，执行某件事，就可以通过<code>window.setTimeout</code>来帮助我们完成。</p><p>像是上面的范例中，<code>window.setTimeout</code>带有两个参数，第一个是要做的事情，用一个函数来代表，第二个则是时间(1/1000 秒, milliseconds)。而第一个参数的函数也是回调函数的一种：「在经过了某段时间之后，才执行的函数」。</p><p>当然，上面两个范例中的回调函数我们也可以把它单独抽出来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> handler = <span class="hljs-function"><span class="hljs-keyword">function</span> 接电话(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br>Office.addEventListener(<span class="hljs-string">&quot;电话响&quot;</span>, handler, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>这样会使你的代码看起来更清楚。</p><p>除了事件以外，还有另一个会需要用到回调函数的场景，就是「<strong>控制多个函数间执行的顺序</strong>」。</p><p>啥意思呢？来看个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> funA = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;function A&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> funB = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;function B&quot;</span>);<br>&#125;;<br><br>funA();<br>funB();<br></code></pre></td></tr></table></figure><p>因为<code>funcA</code>与<code>funcB</code>都会立即执行，并且 JavaScript 的单线程模型决定了同时只能执行一个任务，其他任务都必须在后面排队等待，所以执行结果必定为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span><br><span class="hljs-keyword">function</span> <span class="hljs-title">B</span><br></code></pre></td></tr></table></figure><p>但是，如果<code>funcA</code>是异步操作，<code>funcB</code>会立即执行，不会等到<code>funcA</code>结束再执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> funA = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;function A&quot;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> funB = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;function B&quot;</span>);<br>&#125;;<br><br>funA();<br>funB();<br></code></pre></td></tr></table></figure><p>像这种时候，为了确保先执行<code>funcA</code>，就可以通过回调函数的形式来进行处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 为了确保先执行 funA 再执行 funB</span><br><span class="hljs-comment">// 我们在 funA 加上 callback 参数</span><br><span class="hljs-keyword">var</span> funA = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;function A&quot;</span>);<br><br>    <span class="hljs-comment">// 如果 callback 是个函数就调用它</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      callback();<br>    &#125;<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> funB = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;function B&quot;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 将 funB 作为参数带入 funA()</span><br>funA(funB);<br></code></pre></td></tr></table></figure><p>像这样，无论<code>funA</code>在执行的时候要等多久，<code>funB</code>都会等到<code>console.log(&#39;function A&#39;);</code>之后才执行。</p><p>不过需要注意的是，我们可以将不止一个的回调函数作为参数传递给一个函数，就像我们能够传递不止一个变量一样，过多的异步编程嵌套在一起产生的多重回调函数甚至叫回调地狱，维护起来真的如名字一样会很可怕！</p><p>多重回调函数就类似下面这样的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;参数为 &quot;</span> + arg + <span class="hljs-string">&quot; , 1秒后返回结果&quot;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    callback(arg * <span class="hljs-number">2</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;完成: &quot;</span>, value);<br>&#125;<br><br><span class="hljs-keyword">async</span>(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">async</span>(<span class="hljs-number">3</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      <span class="hljs-keyword">async</span>(<span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-keyword">async</span>(<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>          <span class="hljs-keyword">async</span>(<span class="hljs-number">6</span>, final);<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">参数为 <span class="hljs-number">1</span> , <span class="hljs-number">1</span>秒后返回结果<br>参数为 <span class="hljs-number">2</span> , <span class="hljs-number">1</span>秒后返回结果<br>参数为 <span class="hljs-number">3</span> , <span class="hljs-number">1</span>秒后返回结果<br>参数为 <span class="hljs-number">4</span> , <span class="hljs-number">1</span>秒后返回结果<br>参数为 <span class="hljs-number">5</span> , <span class="hljs-number">1</span>秒后返回结果<br>参数为 <span class="hljs-number">6</span> , <span class="hljs-number">1</span>秒后返回结果<br>完成:  <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p><p>如果真的不幸需要写到这么多层，这点后续我们介绍到<code>Promise</code>时会再说明如何摆脱这种困境。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在之前的文章当中，我们已经介绍了函数的参数与 arguments 对象，那么今天的分享中，我们继续来看看函数在 JavaScript 的各种不同面貌——回调函数。&lt;/p&gt;
&lt;h3 id=&quot;回调函数&quot;&gt;&lt;a href=&quot;#回调函数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="Callback function" scheme="https://me.miqilin21.cn/tags/Callback-function/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件三部曲之事件的兄弟姐妹们</title>
    <link href="https://me.miqilin21.cn/2021/07/03/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9%E4%BB%AC/"/>
    <id>https://me.miqilin21.cn/2021/07/03/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%85%84%E5%BC%9F%E5%A7%90%E5%A6%B9%E4%BB%AC/</id>
    <published>2021-07-02T16:00:00.000Z</published>
    <updated>2021-12-16T03:06:53.021Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的两篇文章中，已经介绍了事件的传达机制，以及如何阻止事件的冒泡与默认的行为。 那么，作为「事件三部曲」的最后一篇，我们就来大概介绍一下，DOM 规范之中究竟提供了哪些事件。</p><h3 id="事件的种类"><a href="#事件的种类" class="headerlink" title="事件的种类"></a>事件的种类</h3><p>浏览器可能发生的事件有很多种，了解这些事件的情境及效果，是 Web 开发不能忽略的基础，接下来介绍一下常见的几种事件：</p><h4 id="界面相关事件"><a href="#界面相关事件" class="headerlink" title="界面相关事件"></a>界面相关事件</h4><p>界面相关的事件不一定会与使用者对 DOM 的操作有关系，反而大多数与 window 对象比较有关系。</p><ul><li><code>load</code> 事件：</li></ul><p>注册在 <code>window</code> 对象上，指的是在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发<code>load</code>事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;load&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;所有资源都加载完成&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>unload</code> 、 <code>beforeunload</code> 事件：</li></ul><p>与 <code>load</code> 事件相反，<code>unload</code> 与 <code>beforeunload</code> 事件分别会在离开页面或重新整理时触发，而 <code>beforeunload</code> 会跳出对话框询问使用者是否要离开当前页面。</p><p><img src="/images/event/7.jpg"></p><ul><li><code>error</code> 事件：</li></ul><p><code>error</code> 事件会在 <code>document</code> 或是图片载入错误时触发。由于考虑到维护性，大多事件的注册我会强烈建议使用「非侵入式 JavaScript」的写法，即 JavaScript 代码和标记的分离。只有 <code>error</code> 事件最适合以 <code>on-event</code> 的写法来处理：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.jpg&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;this.src=&#x27;default.jpg&#x27;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>像这样，当<code>image.jpg</code>这张图片不存在的时候，马上就会触发<code>error</code>事件，就会通过<code>this.src</code>将<code>&lt;img&gt;</code>的 <code>src</code> 属性替换成指定的图片，是相当实用的技巧。</p><p>若是在网页 <code>load</code> 完成后才注册了<code>error</code>事件，你只会看到破图的结果，因为<code>error</code>事件不会再次被触发，后来挂上去的事件处理函数就等于没有一样。</p><ul><li><p><code>resize</code>事件：在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p></li><li><p><code>scroll</code>事件：在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。</p></li><li><p><code>DOMContentLoaded</code>事件：</p></li></ul><p>类似于<code>load</code>事件，但不同的是，<code>load</code>事件是在网页「所有」资源都已经载入完成后才会触发，而<code>DOMContentLoaded</code>事件是在 DOM 结构被完整的读取跟解析后就会被触发，不须等待外部资源读取完成，因此可以这么说，这两者所监听的阶段不同，可以用下面这张图来解释：</p><p><img src="/images/event/8.jpg"></p><p>我们在<a href="https://zhuanlan.zhihu.com/p/66576306">《通过 DOM API 查找节点》</a>这篇文章中曾介绍过，<code>&lt;script&gt;</code>标签要是放在<code>&lt;head&gt; ... &lt;/head&gt;</code>之间，因为还没解析到网页本体会有选取不到 DOM 的问题对吧？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-comment">// 因 Document 结构未载入，无效</span></span><br><span class="javascript">      <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;hello&quot;</span>).textContent = <span class="hljs-string">&quot;Hello&quot;</span>;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么，改成这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">document</span>.addEventListener(</span><br><span class="javascript">        <span class="hljs-string">&quot;DOMContentLoaded&quot;</span>,</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-comment">// 当 document 结构已解析完成才会执行</span></span><br><span class="javascript">          <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;hello&quot;</span>).textContent = <span class="hljs-string">&quot;Hello&quot;</span>;</span><br>        &#125;,<br><span class="javascript">        <span class="hljs-literal">false</span></span><br>      );<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就可以排除<code>&lt;script&gt;</code>标签放在<code>&lt;head&gt; ... &lt;/head&gt;</code>抓不到 DOM 的问题啦。</p><p>与大家所熟知的 <code>jQuery$( document ).ready( handler )</code>作用类似。</p><h4 id="鼠标相关事件"><a href="#鼠标相关事件" class="headerlink" title="鼠标相关事件"></a>鼠标相关事件</h4><ul><li><p><code>mousedown</code> / <code>mouseup</code> 事件: 这两个事件分别会在鼠标点击了某元素「按下」(mousedown) 按钮，以及「放开」(mouseup)按钮时触发。</p></li><li><p><code>click</code> 事件: 当鼠标「点击」了某元素时触发。</p></li><li><p><code>dblclick</code>事件: 当鼠标「连点两次」某元素时触发。</p></li><li><p><code>mouseenter</code> / <code>mousemove</code> / <code>mouseleave</code> 事件：这三个事件要放在一起看：</p></li></ul><ol><li>当鼠标光标移入了某元素时，会先触发 <code>mouseenter</code> 事件。</li><li>鼠标光标在这个元素內「移动」时，会连续触发 <code>mousemove</code> 事件。</li><li>直到鼠标光标离开了这个元素，才触发 <code>mouseleave</code> 事件。</li></ol><p><img src="/images/event/9.gif"></p><p>这些鼠标相关的事件，都可以通过<code>event.pageX</code> 与 <code>event.pageY</code>属性去取得目前鼠标在网页对应的坐标。</p><h4 id="键盘相关事件"><a href="#键盘相关事件" class="headerlink" title="键盘相关事件"></a>键盘相关事件</h4><p>键盘常用相关事件有下列三种，在大多数情况下会将键盘事件注册在 <code>input</code> 的输入框上。</p><ul><li><p><code>keydown</code> 事件: 「压下」键盘按键时会触发 <code>keydown</code> 事件。</p></li><li><p><code>keypress</code> 事件: 除了 Shift, Fn, CapsLock 这三种按键外按住时会触发，若按着不放则会连续触发。</p></li><li><p><code>keyup</code> 事件: 「放开」键盘按键时会触发。</p></li></ul><p>如果我们针对同个元素同时绑定了这三个键盘事件，那么这三个事件执行的顺序会是：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">keydown</span><br><span class="hljs-attribute">keypress</span><br><span class="hljs-attribute">keyup</span><br></code></pre></td></tr></table></figure><p>若此时想要知道使用者按下的按键是哪个，则可以通过<code>event.keyCode</code>属性来查询。<code>keyCode</code>的对应表可以到<a href="https://gist.github.com/tylerbuchea/8011573">这里</a>查看：</p><p>例如，今天你想要当使用者在<code>input</code>输入框按下 「enter」 时，发动<code>submit</code>，就可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">textBox.addEventListener(<br>  <span class="hljs-string">&quot;keydown&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// enter 的 keyCode 是 13</span><br>    <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">13</span>) &#123;<br>      formSubmit();<br>    &#125;<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>像这样，通过<code>e.keyCode</code>就可以判断使用者目前按下的是哪个按钮。</p><h4 id="表单相关事件"><a href="#表单相关事件" class="headerlink" title="表单相关事件"></a>表单相关事件</h4><ul><li><p><code>input</code> 事件： 当 <code>input</code>、 <code>textarea</code> 以及带有 <code>contenteditable</code> 的元素內容被改变时，就会触发 <code>input</code> 事件。</p></li><li><p><code>change</code> 事件： 当 <code>input</code>、<code>select</code>、<code>textarea</code>、<code>radio</code>、<code>checkbox</code> 等表单元素被改变时触发。 但与 <code>input</code> 事件不同的是，<code>input</code> 事件会在输入框输入內容的当下触发，而 <code>change</code> 事件则是在目前焦点离开输入框后才触发。</p></li><li><p><code>submit</code> 事件：当表单被送出时触发，通常表单验证都会在这一步处理，若验证未通过则 <code>return false;</code>。</p></li><li><p><code>focus</code> 事件：当元素被聚焦时触发。</p></li><li><p><code>blur</code> 事件：当元素失去焦点时触发。</p></li></ul><h4 id="特殊事件"><a href="#特殊事件" class="headerlink" title="特殊事件"></a>特殊事件</h4><ul><li>Composition Event (组成事件):</li></ul><p><strong>Composition Event</strong> 其实指的是 <code>compositionstart</code> 、 <code>compositionend</code> ，以及 <code>compositionupdate</code> 这三个事件。</p><p>介绍 Composition Events 之前先来谈谈 DOM API 过去对输入框侦测变化的几个方式：</p><p>常见的表单输入框如: <code>&lt;input type=&quot;text&quot;&gt;</code> 如果要动态监听输入框的文字变化时， 大多会通过监听 <code>keydown</code>、<code>keypress</code>、<code>keyup</code> 等键盘事件来判断 <code>value</code> 是否变动，但如果是通过「<strong>复制粘贴</strong>」之类的操作，就无法通过键盘事件来判断。</p><p>而即使是 <code>change</code> 事件则是要在使用者改变內容，且<strong>焦点离开输入框</strong>的前一刻才会被触发。</p><p>所以后来有了 <code>input</code> 事件， <code>input</code> 事件会在输入框的<strong>內容被改变时即时触发</strong>，确实也解决了过去在 <code>onChange</code> 以及键盘相关事件功能不足所产生的问题。</p><p>但是，新的问题来了！</p><p>通常像这样的搜索框，我们会用类似 <code>autocomplete</code> (自动完成) 的方式给使用者搜索建议 (以 google 为例)：</p><p><img src="/images/event/10.jpg"></p><p>如上图，在输入中文的时候，通常会需要通过注音之类的输入法来做拼字。</p><p>但是在大部分的情況下，针对「注音符号」或是「拼音文字」去给搜索建议是没有太大意义的。</p><p>这个时候就需要通过 <code>Composition Events</code> 来为输入框做增强。</p><p>通过 <code>Composition Events</code> 我们可以观察使用者在输入框內开启输入法 (Input Method Editor, IME) 时，组字或选字的状态。</p><p>Composition Events 提供三个事件给开发者监听：分別是 <code>compositionstart</code> 、 <code>compositionend</code> ，以及 <code>compositionupdate</code>。</p><ul><li><code>compositionstart</code>: 输入框內开启输入法，且正在拼字时触发。</li><li><code>compositionupdate</code>: 输入框內开启输入法，且正在拼字或选字时更改了內容时触发。</li><li><code>compositionend</code>: 输入框內开启输入法，拼字或选字完成，正要送出至输入框时触发。</li></ul><p>执行的时候像这样：</p><p><img src="/images/event/11.jpg"></p><p>可以看到，如果要确认使用者输入完成并送出文字时，就可以通过<code>compositionend</code>来做最后确认。</p><h4 id="自订事件"><a href="#自订事件" class="headerlink" title="自订事件"></a>自订事件</h4><p>自订事件可以用<code>Event constructor</code>建立，同样通过<code>addEventListener</code>去监听，由<code>dispatchEvent</code>决定触发的时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;build&#x27;</span>);<br><br><span class="hljs-comment">// 监听事件</span><br>elem.addEventListener(<span class="hljs-string">&#x27;build&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123; ... &#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 触发事件</span><br>elem.dispatchEvent(event);<br></code></pre></td></tr></table></figure><p>若是想要在自订事件內增加更多资料，则可以改用<code>CustomEvent</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&quot;build&quot;</span>, &#123; <span class="hljs-attr">detail</span>: elem.dataset.time &#125;);<br></code></pre></td></tr></table></figure><p>那么在 Event 处理函数就可以通过<code>event</code>来接收：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eventHandler</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  log(<span class="hljs-string">&quot;The time is: &quot;</span> + e.detail);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，浏览器提供的事件相当多，今天分享的部分主要是比较常见的一些事件，以及工作上实际需要特別注意的部分。</p><p>其他的多数事件你都可以在 MDN 的 <a href="https://developer.mozilla.org/en-US/docs/Web/Events">Event reference</a> 找到。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面的两篇文章中，已经介绍了事件的传达机制，以及如何阻止事件的冒泡与默认的行为。 那么，作为「事件三部曲」的最后一篇，我们就来大概介绍一下，DOM 规范之中究竟提供了哪些事件。&lt;/p&gt;
&lt;h3 id=&quot;事件的种类&quot;&gt;&lt;a href=&quot;#事件的种类&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="事件" scheme="https://me.miqilin21.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="event" scheme="https://me.miqilin21.cn/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件三部曲之隐藏在其中的&#39;秘密&#39;</title>
    <link href="https://me.miqilin21.cn/2021/06/28/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9A%90%E8%97%8F%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/"/>
    <id>https://me.miqilin21.cn/2021/06/28/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9A%90%E8%97%8F%E5%9C%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E7%A7%98%E5%AF%86/</id>
    <published>2021-06-27T16:00:00.000Z</published>
    <updated>2021-12-16T03:07:03.224Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/73091706">上篇文章</a>我们提到，注册事件的方法 addEventListener()内有三个参数，分别是「事件名称」、「事件的处理程序」，以及「捕获」或「冒泡」的机制切换。</p><p>那么，今天我们要来看的第一个部分，就是隐藏在事件处理程序中的<code>event</code> 。</p><h3 id="隐藏在监听函数中的”event”"><a href="#隐藏在监听函数中的”event”" class="headerlink" title="隐藏在监听函数中的”event”"></a>隐藏在监听函数中的”event”</h3><p>当监听的事件发生时，浏览器会去执行我们通过<code>addEventListener()</code>注册的事件处理程序函数。</p><p>这个时候，EventListener 会去创建一个「事件对象」 (Event Object)，里面包含了所有与这个事件相关的属性，并且以「参数」的形式传给我们的处理程序函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;Click&lt;/button&gt;<br>......<br><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>);<br><br><span class="hljs-comment">// 参数 e 就是上面所说的事件对象</span><br><span class="hljs-comment">// 因为是参数，当然可以自己定名称</span><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e);<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>当点击<code>&lt;button&gt;</code>后，可以从<code>console</code>看到<code>event</code>对象中提供了这么多东西：</p><p><img src="/images/event/5.jpg"></p><p>像是</p><ul><li><code>type</code> : 表示事件的名称</li><li><code>target</code> : 表示触发事件的元素</li><li><code>bubbles</code>:表示这事件是否是在「冒泡」阶段触发( <code>true</code>/ <code>false</code>)</li><li><code>pageX</code>/ <code>pageY</code>:表示事件触发时，鼠标座标在网页的相对位置</li></ul><p>其余的属性这里就不一一介绍，不过要注意的是，每个「事件对象」所提供的属性都会根据触发的事件而稍微不同。</p><h3 id="event-preventDefault"><a href="#event-preventDefault" class="headerlink" title="event. preventDefault()"></a>event. preventDefault()</h3><p>HTML 中部分元素会有默认行为，像是<code>&lt;a&gt;</code>标签默认页面跳转或是锚点定位，或是表单的<code>submit</code>等等…</p><p>如果我们需要在这些元素上绑定事件，那么适当地<strong>取消它们的默认行为</strong>就是很重要的一件事。</p><p>比如，有一个通往 baidu 的链接<code>&lt;a&gt;</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;link&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设今天点击这个 link 时，我希望浏览器执行<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;那么根据先前所说，我可以先注册<code>click</code>事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> link = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#link&quot;</span>);<br><br>link.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;米淇淋你好coll!&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>结果你却发现，即便我们在<code>&lt;a&gt;</code>中去注册了<code>click</code>事件，但是当我点击这个 link 的时候，浏览器开始会 console.log 出”米淇淋你好帅!”，但最后 baidu 的网页依旧会覆盖我想要的内容。</p><p>可是我希望执行的是<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;而不是直接把我带偏了去到 baidu 的网站，那么我们该怎么做，才能避免呢？</p><p>这时候如果<strong>调用<code>event.preventDefault()</code>方法，默认事件行为将不再触发</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> link = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#link&quot;</span>);<br><br><span class="hljs-comment">// 在 事件处理函数中 加上 e.preventDefault();</span><br>link.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    e.preventDefault();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;米淇淋你好帅!&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>这个时候，再试着点击 link 一次，你会发现浏览器默认的跳转页面的行为不见了，<code>console.log(&#39;米淇淋你好帅!&#39;)</code>;也可顺利执行啦哈哈。</p><p>但要注意的是，<code>event.preventDefault()</code>并不会阻止事件向上传递(即事件冒泡) 。</p><p>另外，值得一提的是，下面这样设置也可以让 a 标签仅仅当做一个普通的按钮，点击实现一个功能，不想页面跳转，也不想锚点定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:;&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此外，在事件处理函数的<strong>最后</strong>加上<code>return false</code>;也会有<code>event.preventDefault()</code>的效果，但切记不可以加在前面，若是加在前面事件处理函数就直接 gg 了。</p><h3 id="event-stopPropagation-amp-event-stopImmediatePropagation"><a href="#event-stopPropagation-amp-event-stopImmediatePropagation" class="headerlink" title="event.stopPropagation() &amp; event.stopImmediatePropagation()"></a>event.stopPropagation() &amp; event.stopImmediatePropagation()</h3><p>1.<code>event.stopPropagation()</code> 方法阻止事件向上冒泡传递，阻止任何父事件处理程序被执行。</p><p>接下来我们看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div&gt;<br>  &lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>    父元素<br>    &lt;div id=<span class="hljs-string">&quot;child&quot;</span>&gt;子元素&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>......<br><span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;parent&#x27;</span>);<br><span class="hljs-keyword">var</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;child&#x27;</span>);<br><br>child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child bubbling&#x27;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br>parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent bubbling&#x27;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;body bubbling&#x27;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">document</span>.documentElement.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;html bubbling&#x27;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document bubbling&#x27;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;window bubbling&#x27;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">child <span class="hljs-keyword">bubbling</span><br><span class="hljs-keyword">parent </span><span class="hljs-keyword">bubbling</span><br><span class="hljs-keyword">body </span><span class="hljs-keyword">bubbling</span><br><span class="hljs-keyword">html </span><span class="hljs-keyword">bubbling</span><br><span class="hljs-keyword">document </span><span class="hljs-keyword">bubbling</span><br><span class="hljs-keyword">window </span><span class="hljs-keyword">bubbling</span><br></code></pre></td></tr></table></figure><p>而如果在「子元素」中加入<code>event.stopPropagation()</code> 方法，其余保持原样的话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;child bubbling&quot;</span>);<br>    e.stopPropagation();<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>再次点击「子元素」，则只出现：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">child bubbling</span><br></code></pre></td></tr></table></figure><p>其余父事件不会触发，即<code>event.stopPropagation()</code> 方法阻止了事件向上冒泡传递，阻止任何父事件处理程序被执行。</p><p>2.<code>stopImmediatePropagation()</code>方法 <strong>既能阻止事件向父元素冒泡，也能阻止元素同事件类型的其它监听器被触发</strong>。而 stopPropagation 只能实现前者的效果。</p><p>我们来看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;<br>  &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;click me to stop propagation&lt;/button&gt;<br>&lt;/body&gt;<br>......<br><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>);<br><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;btn click 1&#x27;</span>);<br>  <span class="hljs-comment">//e.stopImmediatePropagation();</span><br>&#125;);<br><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;btn click 2&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;body click&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">document</span>.documentElement.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;html click&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;document click&#x27;</span>);<br>&#125;);<br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;window click&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>当我点击 button 的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">btn <span class="hljs-built_in">click</span> <span class="hljs-number">1</span><br>btn <span class="hljs-built_in">click</span> <span class="hljs-number">2</span><br>body <span class="hljs-built_in">click</span><br>html <span class="hljs-built_in">click</span><br>document <span class="hljs-built_in">click</span><br>window <span class="hljs-built_in">click</span><br></code></pre></td></tr></table></figure><p>而如果在「btn 的第一个监听函数」中加入<code>event.stopImmediatePropagation()</code> 方法，其余保持原样的话：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;btn click 1&quot;</span>);<br>  e.stopImmediatePropagation();<br>&#125;);<br></code></pre></td></tr></table></figure><p>再次点击 button，则只出现：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">btn click <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>所以说，使用 <code>stopImmediatePropagation()</code> 方法后，点击按钮时，仅触发设置了<code>stopImmediatePropagation()</code> 方法的监听器，与此同时按钮的其余同类型点击事件不触发。</p><h3 id="event-target-amp-event-currentTarget"><a href="#event-target-amp-event-currentTarget" class="headerlink" title="event.target &amp; event.currentTarget"></a>event.target &amp; event.currentTarget</h3><p>老实说并不能好好用文字描述这两者的区别，我们直接看个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;style&gt;<br>  #a&#123;<br>    width: <span class="hljs-number">200</span>px;<br>    height: <span class="hljs-number">200</span>px;<br>    background: yellow       ;<br>  &#125;<br>  #b&#123;<br>    width: <span class="hljs-number">150</span>px;<br>    height: <span class="hljs-number">150</span>px;<br>    background: green;<br>  &#125;<br>  #c&#123;<br>    width: <span class="hljs-number">100</span>px;<br>    height: <span class="hljs-number">100</span>px;<br>    background: grey;<br>  &#125;<br>  #d&#123;<br>    width: <span class="hljs-number">50</span>px;<br>    height: <span class="hljs-number">50</span>px;<br>    background: black;<br>  &#125;<br>&lt;/style&gt;<br>......<br>&lt;div id=<span class="hljs-string">&quot;a&quot;</span>&gt;<br>  &lt;div id=<span class="hljs-string">&quot;b&quot;</span>&gt;<br>    &lt;div id=<span class="hljs-string">&quot;c&quot;</span>&gt;<br>      &lt;div id=<span class="hljs-string">&quot;d&quot;</span>&gt;&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br>......<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;a&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">&#x27;target:&#x27;</span> + e.target.id + <span class="hljs-string">&#x27;&amp;currentTarget:&#x27;</span> + e.currentTarget.id<br>    )<br>&#125;)<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;b&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">&#x27;target:&#x27;</span> + e.target.id + <span class="hljs-string">&#x27;&amp;currentTarget:&#x27;</span> + e.currentTarget.id<br>    )<br>&#125;)<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;c&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">&#x27;target:&#x27;</span> + e.target.id + <span class="hljs-string">&#x27;&amp;currentTarget:&#x27;</span> + e.currentTarget.id<br>    )<br>&#125;)<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;d&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<br>      <span class="hljs-string">&#x27;target:&#x27;</span> + e.target.id + <span class="hljs-string">&#x27;&amp;currentTarget:&#x27;</span> + e.currentTarget.id<br>    )<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://jsbin.com/rubedoqepi/edit?html,js,output">jsbin</a> 点这里。</p><p><img src="/images/event/6.gif"></p><p>当我们点击最里层黑色区域的元素 d 的时候，会依次输出:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">target</span><span class="hljs-selector-pseudo">:d</span>&amp;<span class="hljs-selector-tag">currentTarget</span><span class="hljs-selector-pseudo">:d</span><br><span class="hljs-selector-tag">target</span><span class="hljs-selector-pseudo">:d</span>&amp;<span class="hljs-selector-tag">currentTarget</span><span class="hljs-selector-pseudo">:c</span><br><span class="hljs-selector-tag">target</span><span class="hljs-selector-pseudo">:d</span>&amp;<span class="hljs-selector-tag">currentTarget</span><span class="hljs-selector-pseudo">:b</span><br><span class="hljs-selector-tag">target</span><span class="hljs-selector-pseudo">:d</span>&amp;<span class="hljs-selector-tag">currentTarget</span><span class="hljs-selector-pseudo">:a</span><br></code></pre></td></tr></table></figure><p>从输出中我们可以看到，<code>event.target</code>指向引起触发事件的元素，而<code>event.currentTarget</code>则是事件绑定的元素，只有被点击的那个目标元素的<code>event.target</code>才会等于<code>event.currentTarget</code>。<strong>也就是说，<code>event.currentTarget</code>始终是监听事件者，而<code>event.target</code>是事件的真正发出者</strong>。</p><p>另外，值得一提的是，function 内部的<code>this</code>指的也就是<code>event.currentTarget</code>。</p><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件代理或叫事件委托（Event Delegation）。</p><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h4><ul><li>减少内存消耗，提高性能</li></ul><p>假设有一个列表，列表之中有大量的列表项，我们需要在点击每个列表项的时候响应一个事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myList&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  ......<br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item n<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果给每个列表项都绑定一个函数，假如此时列表项很多，那无疑对内存的消耗是非常大的，并且效率上需要消耗很多性能。借助事件代理，我们只需要给父容器 <code>ul</code> 绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的 click 行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。</p><ul><li>动态绑定事件</li></ul><p>在很多时候，我们需要通过用户操作动态的增删列表项元素，如果一开始给每个子元素绑定事件，那么在列表发生变化时，就需要重新给新增的元素绑定事件，给即将删去的元素解绑事件，如果用事件代理就会省去很多这样麻烦。</p><h4 id="2-如何实现"><a href="#2-如何实现" class="headerlink" title="2.如何实现"></a>2.如何实现</h4><p>接下来我们来实现上例中父层元素 <code>#myList</code> 下的 <code>li</code> 元素的事件委托到它的父层元素上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 取得容器</span><br><span class="hljs-keyword">var</span> myList = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;myList&quot;</span>);<br><br><span class="hljs-comment">// 让父层 myList 来监听 click 事件</span><br>myList.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// 判断目标元素若是 li 则执行 console.log</span><br>    <span class="hljs-keyword">if</span> (e.target.tagName.toLowerCase() === <span class="hljs-string">&quot;li&quot;</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(e.target.textContent);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br><br><span class="hljs-comment">// 建立新的 &lt;li&gt; 元素</span><br><span class="hljs-keyword">var</span> newList = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;li&quot;</span>);<br><br><span class="hljs-comment">// 建立 textNode 文字节点</span><br><span class="hljs-keyword">var</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br><br><span class="hljs-comment">// 通过 appendChild 将 textNode 加入至 newList</span><br>newList.appendChild(textNode);<br><br><span class="hljs-comment">// 通过 appendChild 将 newList 加入至 myList</span><br>myList.appendChild(newList);<br></code></pre></td></tr></table></figure><p>我们把<code>click</code>事件改由父层的<code>myList</code>来监听，利用事件传递的原理，判断<code>e.target</code>是我们想要的目标节点时，才去执行后续的动作。</p><p>这样的好处是你的事件管理会非常轻松，而且后续加上的<code>newList</code>也会有<code>click</code>的效果，无需另外再去绑定<code>click</code>事件。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/73091706&quot;&gt;上篇文章&lt;/a&gt;我们提到，注册事件的方法 addEventListener()内有三个参数，分别是「事件名称」、「事件的处理程序」，以及「捕获」或「冒泡」的机制切换。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="事件" scheme="https://me.miqilin21.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="event" scheme="https://me.miqilin21.cn/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件三部曲之事件机制的原理</title>
    <link href="https://me.miqilin21.cn/2021/06/26/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://me.miqilin21.cn/2021/06/26/JavaScript%E4%BA%8B%E4%BB%B6%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-25T16:00:00.000Z</published>
    <updated>2021-12-16T03:07:48.753Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 是一个事件驱动(Event-driven) 的语言，当浏览器载入网页开始读取后，虽然马上会读取 JavaScript 事件相关的代码，但是必须要等到「事件」被触发(如使用者点击、按下键盘等)后，才会再进行对应代码段的执行。</p><p>啥意思呢？</p><p>就好比放了一部电话在家里，但是电话要是没响，我们不会主动去「接电话」 (没人打来当然也无法主动接) ，这里电话响了就好比事件被触发，接电话就好比去做对应的事情。</p><h3 id="电话响了-事件被触发-gt-接电话-去做对应的事"><a href="#电话响了-事件被触发-gt-接电话-去做对应的事" class="headerlink" title="电话响了(事件被触发) -&gt; 接电话(去做对应的事)"></a>电话响了(事件被触发) -&gt; 接电话(去做对应的事)</h3><p>换以我们很常见的网页对话框 UI 来说，当使用者「按下了按钮」之后，才会启动对话框的显示。如果使用者没有按下按钮，就狂跳对话框，那使用者一定觉得这网站瓦特了吧。</p><p>以 Bootstrap Modal 为例：</p><p><img src="/images/event/1.gif"></p><p>在上面的例子中，当使用者点击了按钮，才会启动对话框的显示，那么「点击按钮」这件事，就被称作「<strong>事件</strong>」(Event)，而负责处理事件的代码段通常被称为「<strong>事件处理程序</strong>」(Event Handler)，也就是「启动对话框的显示」这个动作。</p><p>看完上面的例子，想必大家对事件有了一定的理解了吧，接下来就深入来探讨 DOM 事件。</p><h3 id="DOM-事件级别"><a href="#DOM-事件级别" class="headerlink" title="DOM 事件级别"></a>DOM 事件级别</h3><p>DOM 有 4 次版本更新，与 DOM 版本变更，产生了 3 种不同的 DOM 事件：<strong>DOM 0 级事件处理，DOM 2 级事件处理和 DOM 3 级事件处理</strong>。由于 DOM 1 级中没有事件的相关内容，所以没有 DOM 1 级事件。</p><h4 id="DOM-0-级事件"><a href="#DOM-0-级事件" class="headerlink" title="DOM 0 级事件"></a>DOM 0 级事件</h4><p>1.on-event (HTML 属性)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;xxx&#x27;)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，基于代码的使用性与维护性考量，现在已经不建议用此方式来绑定事件。</p><p>on-event (非 HTML 属性)：</p><p>像是<code>window</code>或<code>document</code>此类没有实体元素的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;Hello world!&quot;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>若是实体元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">// HTML<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>// JavaScript var btn = document.getElementById(&#x27;btn&#x27;); btn.onclick =<br>function()&#123; alert(&#x27;xxx&#x27;); &#125;<br></code></pre></td></tr></table></figure><p>若想解除事件的话，则重新指定<code>on-event</code>为<code>null</code>即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.onclick = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>2.同一个元素的同一种事件只能绑定一个函数，否则后面的函数会覆盖之前的函数</p><p>3.不存在兼容性问题</p><h4 id="DOM-2-级事件"><a href="#DOM-2-级事件" class="headerlink" title="DOM 2 级事件"></a>DOM 2 级事件</h4><p>1.Dom 2 级事件是通过 <code>addEventListener</code> 绑定的事件</p><p>2.同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行</p><p>3.解绑 Dom 2 级事件时，使用 <code>removeEventListener</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn.removeEventListener(<span class="hljs-string">&quot;click&quot;</span>, a);<br></code></pre></td></tr></table></figure><p>Dom 2 级事件有三个参数：第一个参数是事件名（如<code>click</code>）；第二个参数是事件处理程序函数；第三个参数如果是<code>true</code>的话表示在捕获阶段调用，为<code>false</code>的话表示在冒泡阶段调用。捕获阶段和冒泡阶段在下一节具体介绍。</p><p>还有注意<code>removeEventListener()</code>:不能移除匿名添加的函数。</p><h4 id="DOM-3-级事件"><a href="#DOM-3-级事件" class="headerlink" title="DOM 3 级事件"></a>DOM 3 级事件</h4><p>DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，增加的类型如下：</p><ul><li>UI 事件，当用户与页面上的元素交互时触发，如：load、scroll</li><li>焦点事件，当元素获得或失去焦点时触发，如：blur、focus</li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup</li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel</li><li>文本事件，当在文档中输入文本时触发，如：textInput</li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress</li><li>合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart</li><li>变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified</li><li>同时 DOM3 级事件也允许使用者自定义一些事件。</li></ul><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><p>事件流(Event Flow)指的就是「<strong>网页元素接收事件的顺序</strong>」。事件流可以分成两种机制：</p><ul><li>事件捕获(Event Capturing)</li><li>事件冒泡(Event Bubbling)</li></ul><p>当一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段：</p><ol><li>捕获阶段：事件从<code>window</code>对象自上而下向目标节点传播的阶段；</li><li>目标阶段：真正的目标节点正在处理事件的阶段；</li><li>冒泡阶段：事件从目标节点自下而上向<code>window</code>对象传播的阶段。</li></ol><p>接着就来分别介绍事件捕获和事件冒泡这两种机制。</p><h4 id="事件捕获-Event-Capturing"><a href="#事件捕获-Event-Capturing" class="headerlink" title="事件捕获(Event Capturing)"></a>事件捕获(Event Capturing)</h4><p><img src="/images/event/2.jpg"></p><p>事件捕获指的是「从启动事件的元素节点开始，逐层往下传递」，直到最下层节点，也就是<code>div</code>。</p><p>假设 HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>米淇淋是个大帅哥<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件捕获」的机制下，触发事件的顺序会是：</p><ol><li><code>document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;div&gt;点我&lt;/div&gt;</code></li></ol><p>像这样<code>click</code>事件由上往下依序被触发，就是「事件捕获」机制。</p><h4 id="事件冒泡-Event-Bubbling"><a href="#事件冒泡-Event-Bubbling" class="headerlink" title="事件冒泡(Event Bubbling)"></a>事件冒泡(Event Bubbling)</h4><p><img src="/images/event/3.jpg"></p><p>刚刚说过「事件捕获」机制是由上往下来传递，那么「事件冒泡」(Event Bubbling) 机制则正好相反。</p><p>假设 HTML 同样如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>米淇淋是个大帅哥<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>假设我们点击(click)了<code>&lt;div&gt;点我&lt;/div&gt;</code>元素，那么在「事件冒泡」的机制下，触发事件的顺序会是：</p><ol><li><code>&lt;div&gt;点我&lt;/div&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;html&gt;</code></li><li><code>document</code></li></ol><p>像这样<code>click</code>事件逐层向上依序被触发，就是「事件冒泡」机制。</p><p>既然事件传递顺序有这两种机制，那<strong>我怎么知道事件是依据哪种机制</strong>执行的呢？</p><p>答案是：两种都会执行。</p><p><img src="/images/event/4.jpg"></p><p>假设现在的事件是点击上图中蓝色的<code>&lt;td&gt;</code>。</p><p>那么当 td 的<code>click</code>事件发生时，会先走红色的「capture phase」：</p><ol><li><code>Document</code></li><li><code>&lt;html&gt;</code></li><li><code>&lt;body&gt;</code></li><li><code>&lt;table&gt;</code></li><li><code>&lt;tbody&gt;</code></li><li><code>&lt;tr&gt;</code></li><li><code>&lt;td&gt;</code> (实际被点击的元素)</li></ol><p>由上而下依序触发它们的<code>click</code>事件。</p><p>然后到达「Target phase」后再继续执行绿色的「bubble phase」，反方向由<code>&lt;td&gt;</code>一路往上传至<code>Document</code>，整个事件流到此结束。</p><p>要检验事件流，我们可以通过<code>addEventListener()</code>方法来绑定<code>click</code>事件：</p><p>假设 HTML 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    父元素<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>子元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;parent&quot;</span>);<br><span class="hljs-keyword">var</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;child&quot;</span>);<br><br><span class="hljs-comment">// 通过 addEventListener 指定事件的绑定</span><br><span class="hljs-comment">// 第三个参数 true / false 分別代表 捕获/ 冒泡 机制</span><br><br>parent.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent Capturing&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br><br>parent.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Parent Bubbling&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br><br>child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child Capturing&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br><br>child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child Bubbling&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>当我点击的是「子元素」的时候，通过<code>console.log</code>可以观察到事件触发的顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;Parent Capturing&quot;</span>;<br><span class="hljs-string">&quot;Child Capturing&quot;</span>;<br><span class="hljs-string">&quot;Child Bubbling&quot;</span>;<br><span class="hljs-string">&quot;Parent Bubbling&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>而如果直接点击「父元素」，则出现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;Parent Capturing&quot;</span>;<br><span class="hljs-string">&quot;Parent Bubbling&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>由此可知，点击子元素的时候，父层的<code>Capturing</code>会先被触发，然后再到子层内部的<code>Capturing</code>或<code>Bubbling</code>事件。最后才又回到父层的<code>Bubbling</code>结束。点击父元素的时候，不会经过子元素，子层的<code>Capturing</code>和<code>Bubbling</code>都不会触发。</p><p>那么，子层中的<code>Capturing</code>或<code>Bubbling</code>谁先谁后呢？要看你代码的顺序而定：</p><p>若是<code>Capturing</code>在<code>Bubbling</code>前面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child Capturing&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br><br>child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child Bubbling&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>则会得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;Child Capturing&quot;</span>;<br><span class="hljs-string">&quot;Child Bubbling&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>若是将两段代码段顺序反过来的话，就会是这样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child Bubbling&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br><br>child.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Child Capturing&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>);<br></code></pre></td></tr></table></figure><p>则会得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;Child Bubbling&quot;</span>;<br><span class="hljs-string">&quot;Child Capturing&quot;</span>;<br><br></code></pre></td></tr></table></figure><h3 id="事件监听-EventTarget-addEventListener"><a href="#事件监听-EventTarget-addEventListener" class="headerlink" title="事件监听 EventTarget.addEventListener()"></a>事件监听 EventTarget.addEventListener()</h3><p><code>addEventListener()</code>基本上有三个参数，分别是「事件名称」、「事件的处理程序」(事件触发时执行的<code>function</code>)，以及一个「Boolean」值，由这个 Boolean 决定事件是以「捕获」还是「冒泡」机制执行，若不指定则预设为「冒泡」。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">// HTML<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>// JavaScript var btn = document.getElementById(&#x27;btn&#x27;);<br>btn.addEventListener(&#x27;click&#x27;, function()&#123; console.log(&#x27;HI&#x27;); &#125;, false);<br></code></pre></td></tr></table></figure><p>使用这种方式来注册事件的好处是：同一个元素的同种事件可以绑定多个函数，按照绑定顺序执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);<br><br>btn.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HI&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br><br>btn.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HELLO&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>点击后<code>console</code>出现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;HI&quot;</span>;<br><span class="hljs-string">&quot;HELLO&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>若要解除事件的监听，则是通过<code>removeEventListener()</code>来取消。</p><p><code>removeEventListener()</code>的三个参数与<code>addEventListener()</code>一样，分别是「事件名称」、「事件的处理程序」以及代表「捕获」或「冒泡」机制的「Boolean」值。</p><p>但是需要注意的是，由于<code>addEventListener()</code>可以同时针对某个事件绑定多个函数，所以通过<code>removeEventListener()</code>解除事件的时候，第二个参数的函数必须要与先前在<code>addEventListener()</code>绑定的函数是同一个「实体」。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);<br><br>btn.addEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HI&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br><br><span class="hljs-comment">// 移除事件，但是没用</span><br>btn.removeEventListener(<br>  <span class="hljs-string">&quot;click&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HI&quot;</span>);<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>);<br></code></pre></td></tr></table></figure><p>像上面这样，即使执行了<code>removeEventListener</code>来移除事件，但<code>click</code>时仍会出现’HI’。因为<code>addEventListener</code>与<code>removeEventListener</code>所移除的函数实际上是两个不同实体的 function 对象。</p><p>不知道为什么这两个 function 是两个不同实体的朋友请参考：<a href="https://zhuanlan.zhihu.com/p/63114665">《JavaScript 系列之内存空间》</a>。简单理解就是两个 function 指向不同的内存地址，代表来自于不同实体。</p><p>稍加改进后就能如愿移除了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);<br><br><span class="hljs-comment">// 把 event 函数程序拉出來</span><br><span class="hljs-keyword">var</span> clickHandler = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HI&quot;</span>);<br>&#125;;<br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, clickHandler, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 移除 clickHandler， ok!</span><br>btn.removeEventListener(<span class="hljs-string">&quot;click&quot;</span>, clickHandler, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>那么以上就是今天为各位介绍 JavaScript 事件机制原理的部分。</p><p>接下来的文章我会继续来介绍事件的种类，以及更多实际上处理「事件」时需要注意的事项。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 是一个事件驱动(Event-driven) 的语言，当浏览器载入网页开始读取后，虽然马上会读取 JavaScript 事件相关的代码，但是必须要等到「事件」被触发(如使用者点击、按下键盘等)后，才会再进行对应代码段的执行。&lt;/p&gt;
&lt;p&gt;啥意思呢？&lt;/</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="事件" scheme="https://me.miqilin21.cn/tags/%E4%BA%8B%E4%BB%B6/"/>
    
    <category term="event" scheme="https://me.miqilin21.cn/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之类数组对象arguments</title>
    <link href="https://me.miqilin21.cn/2021/06/19/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1arguments/"/>
    <id>https://me.miqilin21.cn/2021/06/19/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1arguments/</id>
    <published>2021-06-18T16:00:00.000Z</published>
    <updated>2021-12-16T03:08:01.293Z</updated>
    
    <content type="html"><![CDATA[<p>之前在<a href="https://zhuanlan.zhihu.com/p/71490991">《JavaScript 系列之 this 是什么》</a>这篇文章中，我们曾谈过”this”这个关键字，本章将会谈到另一个 JavaScript 中的关键字，叫做”arguments”。</p><p>那<code>arguments</code>到底是什么呢？下面就由我来简洁地介绍一下 <code>arguments</code>吧。</p><h3 id="什么是参数-parameters"><a href="#什么是参数-parameters" class="headerlink" title="什么是参数(parameters)"></a>什么是参数(parameters)</h3><p>在了解<code>arguments</code>之前，我们必须要先了解一下什么是参数(parameter)。参数其实就是我们会带入函数的变量，以下面例子来说，”house”、”car”、”money”，就是我们在执行函式的时候可以任意填入的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFavorite</span>(<span class="hljs-params">house, car, money</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(house);<br>  <span class="hljs-built_in">console</span>.log(car);<br>  <span class="hljs-built_in">console</span>.log(money);<br>&#125;<br><br>MyFavorite();<br></code></pre></td></tr></table></figure><p>首先，当我建立好这样的函数，我可以不带任何参数值就去执行这个函数，只要输入<code>MyFavorite()</code>这样就可以了！</p><p>一般如果有参数却又没有给它参数值，函数的执行上往往会有错误！但在 JavaScript 中不太一样的地方在于，即使你没有给它任何参数值就加以执行，也不会报错，而是会返回<code>undefined</code>。</p><p><img src="/images/arguments/1.jpg"></p><p>为什么会得到”<code>undefined</code>“呢？</p><p>之所以会这样是因为当 JavaScript 在执行这个函数的时候，由于提升机制，它会先把我们的参数(<code>house</code>, <code>car</code>, <code>money</code>)存到内存中了，并且赋予它的值是<code>undefined</code>。</p><p>参数值会由左至右读取，如果我依序执行这样的代码就理解了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">MyFavorite();<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>);<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>, <span class="hljs-string">&quot;法拉利&quot;</span>);<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>, <span class="hljs-string">&quot;法拉利&quot;</span>, <span class="hljs-string">&quot;一亿元&quot;</span>);<br></code></pre></td></tr></table></figure><p>会分别读到以下的结果，表示 JavaScript 会由左至右来读取参数值，而且即使某些参数值有缺值的情况，JavaScript 还是可以正常执行。</p><p><img src="/images/arguments/2.jpg"></p><h3 id="设置函数中参数的默认值"><a href="#设置函数中参数的默认值" class="headerlink" title="设置函数中参数的默认值"></a>设置函数中参数的默认值</h3><p>由于目前的几款浏览器使用的 JavaScript 版本都尚不支持直接在参数的地方设置默认值（ES6 的将可以），所以很多的框架都还不会用这种方式设置默认值。</p><p><strong>方法一：在 ES6 的 JavaScript 中，可以直接通过这种方式设置参数默认值：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFavorite</span>(<span class="hljs-params">house, car, money = <span class="hljs-string">&quot;一亿元&quot;</span></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(house);<br>  <span class="hljs-built_in">console</span>.log(car);<br>  <span class="hljs-built_in">console</span>.log(money);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;----------------&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：利用强制转换的概念设置默认值</strong></p><p>由于版本兼容的差异，现今多数的编程都是使用这种方式设置参数的默认值，利用简单的”=”和”||”就可以达到参数默认值的效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFavorite</span>(<span class="hljs-params">house, car, money</span>) </span>&#123;<br>  money = money || <span class="hljs-string">&quot;一亿元&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(house);<br>  <span class="hljs-built_in">console</span>.log(car);<br>  <span class="hljs-built_in">console</span>.log(money);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;----------------&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候即使在没有给值的情况下，<code>money</code>一样可以得到默认值为”一亿元”：</p><p><img src="/images/arguments/3.jpg"></p><h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><p>了解了<code>parameters</code>的概念后，让我们回来谈谈<code>arguments</code>，MDN 将它叫做类数组对象，那么什么是类数组对象呢？</p><p>所谓的类数组对象:</p><blockquote><p>就是拥有一个 <code>length</code> 属性和若干索引属性的对象</p></blockquote><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> array = [<span class="hljs-string">&#x27;house&#x27;</span>, <span class="hljs-string">&#x27;car&#x27;</span>, <span class="hljs-string">&#x27;money&#x27;</span>];<br><br><span class="hljs-keyword">var</span> arrayLike = &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;house&#x27;</span>,<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;car&#x27;</span>,<br>    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;money&#x27;</span>,<br>    length: <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-comment">//读取</span><br><span class="hljs-built_in">console</span>.log(array[<span class="hljs-number">0</span>]); <span class="hljs-comment">// house</span><br><span class="hljs-built_in">console</span>.log(arrayLike[<span class="hljs-number">0</span>]); <span class="hljs-comment">// house</span><br><br>array[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new house&#x27;</span>;<br>arrayLike[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;new house&#x27;</span>;<br><br><span class="hljs-comment">//长度</span><br><span class="hljs-built_in">console</span>.log(array.length); <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.log(arrayLike.length); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = array.length; i &lt; len; i++</span>)</span> &#123;<br>   ……<br>&#125;<br><span class="hljs-function"><span class="hljs-title">for</span>(<span class="hljs-params"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arrayLike.length; i &lt; len; i++</span>)</span> &#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><p>上面我们可以看得出来，类数组对象与数组在读取、获取长度、遍历三个方面一样，都能取到，那为什么还叫做类数组对象呢？</p><p>因为类数组对象不可以使用数组的方法，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arrayLike.push(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><p>然而上述代码会报错: <code>arrayLike.push is not a function</code>，所以终归还是类数组呐……</p><h3 id="调用数组方法"><a href="#调用数组方法" class="headerlink" title="调用数组方法"></a>调用数组方法</h3><p>如果类数组想用数组的方法怎么办呢？</p><p>直接调用是不可取的，那我们可以通过 <code>Function.call</code> 的方法进行间接调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arrayLike = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&quot;house&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;car&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;money&quot;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> &#125;;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.join.call(arrayLike, <span class="hljs-string">&quot;&amp;&quot;</span>)); <span class="hljs-comment">// house&amp;car&amp;money</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike, <span class="hljs-number">0</span>)); <span class="hljs-comment">// [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;]</span><br><span class="hljs-comment">// slice可以做到类数组转数组</span><br><br><span class="hljs-built_in">Array</span>.prototype.map.call(arrayLike, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item.toUpperCase();<br>&#125;);<br><span class="hljs-comment">// [&quot;HOUSE&quot;, &quot;CAR&quot;, &quot;MONEY&quot;]</span><br></code></pre></td></tr></table></figure><p>在上面已经提到了一种类数组转数组的方法，再补充三个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arrayLike = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&quot;house&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;car&quot;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&quot;money&quot;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-comment">// 1. slice</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike)); <span class="hljs-comment">// [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;]</span><br><span class="hljs-comment">// 2. splice</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.splice.call(arrayLike, <span class="hljs-number">0</span>)); <span class="hljs-comment">// [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;]</span><br><span class="hljs-comment">// 3. ES6 Array.from</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.from(arrayLike)); <span class="hljs-comment">// [&quot;house&quot;, &quot;car&quot;, &quot;money&quot;]</span><br><span class="hljs-comment">// 4. apply</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.prototype.concat.apply([], arrayLike));<br></code></pre></td></tr></table></figure><p>接下来重点讲讲 <code>Arguments</code> 这个类数组对象。</p><h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h3><p><code>arguments</code>比起<code>this</code>来说，要容易理解的多，<code>arguments</code>对象只定义在函数体中，包括了函数的参数和其他属性。</p><p>同样地通过上面的例子加以理解，我们直接在函数中去打印出”arguments”这个关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFavorite</span>(<span class="hljs-params">house, car, money</span>) </span>&#123;<br>  money = money || <span class="hljs-string">&quot;一亿元&quot;</span>;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;----------------&quot;</span>);<br>&#125;<br><br>MyFavorite();<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>);<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>, <span class="hljs-string">&quot;法拉利&quot;</span>);<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>, <span class="hljs-string">&quot;法拉利&quot;</span>, <span class="hljs-string">&quot;一亿元&quot;</span>);<br></code></pre></td></tr></table></figure><p>打印结果如下：</p><p><img src="/images/arguments/4.jpg"></p><p>我们可以看到除了类数组的索引属性和<code>length</code>属性之外，还有一个<code>callee</code>属性，而且我们可以看到<code>arguments</code>对象的<code>__ proto __</code>是指向<code>object</code>的，这也说明了他是个类数组对象，而不是一个数组。下面我们进行一一介绍。</p><h4 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h4><p><code>arguments.length</code>为函数实参个数，举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">house, car, money</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;实参的长度为：&quot;</span> + <span class="hljs-built_in">arguments</span>.length);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;形参的长度为：&quot;</span> + foo.length);<br><br>foo(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 形参的长度为：3</span><br><span class="hljs-comment">// 实参的长度为：1</span><br></code></pre></td></tr></table></figure><h4 id="callee-属性"><a href="#callee-属性" class="headerlink" title="callee 属性"></a>callee 属性</h4><p>每个参数实例都有一个<code>callee</code>属性，通过它可以调用函数自身。 ES5 的严格模式不允许访问<code>arguments.callee</code>。</p><p>讲个闭包经典面试题使用 <code>callee</code> 的解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = [];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  (data[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.callee.i);<br>  &#125;).i = i;<br>&#125;<br><br>data[<span class="hljs-number">0</span>]();<br>data[<span class="hljs-number">1</span>]();<br>data[<span class="hljs-number">2</span>]();<br><br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="最后来看看展开运算符-spread-…"><a href="#最后来看看展开运算符-spread-…" class="headerlink" title="最后来看看展开运算符 spread(…)"></a>最后来看看展开运算符 spread(…)</h3><p>除了<code>arguments</code>这个关键字，在新版 ES6 的 JavaScript 中另外提供了一个展开运算符(spread)，它就是「<code>...</code>」三个点，这个<code>...</code>有什么用呢？</p><p>根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">MDN</a>对于展开运算符 spread 的描述如下：</p><blockquote><p>The spread operator allows an expression to be expanded in places where multiple arguments (for function calls) or multiple elements (for array literals) or multiple variables (for destructuring assignment) are expected.</p></blockquote><p>简单来说，就是它可以把函数中许多的参数(<code>arguments</code>)或数组中许多的元素(<code>elements</code>)形成一个新的变量。</p><p>举例来说：</p><p>在函数的部分，在参数的地方我们用”<code>...other</code>“，<code>other</code>是你想要储存成的数组变量名称，可以自己取。</p><p>在执行函数的地方，原本我们只有三个参数(<code>house</code>, <code>car</code>, <code>money</code>)，也只能填写三个参数；但使用了展开运算符”<code>...</code>“后，我们在执行函数的地方就可以带入不只三个参数（例如，我在最后面又加了”老婆”和”孩子”），这些多的参数值最后都会被放到<code>other</code>这个数组当中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFavorite</span>(<span class="hljs-params">house, car, money, ...other</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(other);<br>  <span class="hljs-built_in">console</span>.log(<br>    <span class="hljs-string">&quot;What my favorite are&quot;</span> + house + <span class="hljs-string">&quot;,&quot;</span> + car + <span class="hljs-string">&quot;,&quot;</span> + money + <span class="hljs-string">&quot;,&quot;</span> + other<br>  );<br>&#125;<br><br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>, <span class="hljs-string">&quot;法拉利&quot;</span>, <span class="hljs-string">&quot;一亿&quot;</span>);<br>MyFavorite(<span class="hljs-string">&quot;别墅&quot;</span>, <span class="hljs-string">&quot;法拉利&quot;</span>, <span class="hljs-string">&quot;一亿&quot;</span>, <span class="hljs-string">&quot;老婆&quot;</span>, <span class="hljs-string">&quot;孩子&quot;</span>);<br></code></pre></td></tr></table></figure><p>结果就会长的像这样子：</p><p><img src="/images/arguments/5.jpg"></p><p>展开运算符还有其他的使用方式，像是把数组元素做连接等等，使用灵活的话相当方便，如果有需要的话，可以参考引 1。</p><p>引 1：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Microsoft Developer Netword：展开运算符(…)</a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>1.利用 arguments 实现方法的重载</strong></p><p>下面我们利用<code>arguments</code>对象来实现一个参数相加的函数，不论传入多少参数都行，将传入的参数相加后返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">arguments</span>.length,<br>    sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; len--; ) &#123;<br>    sum += <span class="hljs-built_in">arguments</span>[len];<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">//6</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">//4</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)); <span class="hljs-comment">//17</span><br></code></pre></td></tr></table></figure><p>由于 JS 是一种弱类型的语言，没有重载机制，当我们重写函数时，会将原来的函数直接覆盖，这里我们能利用<code>arguments</code>，来判断传入的实参类型与数量进行不同的操作，然后返回不同的数值。</p><p><strong>2.利用 arguments.callee 实现递归</strong></p><p>先来看看平常我们是怎么实现递归的，这是一个结算阶乘的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> num * foo(num - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是当这个函数变成了一个匿名函数时，我们就可以利用<code>callee</code>来递归这个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> num * <span class="hljs-built_in">arguments</span>.callee(num - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法虽然好用，但是有一点值得注意，ECMAScript4 中为了限制 JS 的灵活度，让 JS 变得严格，新增了严格模式，在严格模式中我们被禁止不使用<code>var</code>来直接声明一个全局变量，当然这不是重点，重点是<code>arguments.callee</code>这个属性也被禁止了。不过这都不是事儿，ES6 为我们新增了很多好用的变量声明方式和新的语法糖，作为一个时髦的前端，我们赶紧学习一些 ES6 的新语法吧。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前在&lt;a href=&quot;https://zhuanlan.zhihu.com/p/71490991&quot;&gt;《JavaScript 系列之 this 是什么》&lt;/a&gt;这篇文章中，我们曾谈过”this”这个关键字，本章将会谈到另一个 JavaScript 中的关键字，叫做”argu</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="arguments" scheme="https://me.miqilin21.cn/tags/arguments/"/>
    
  </entry>
  
  <entry>
    <title>Flexbox 对你说爱不完</title>
    <link href="https://me.miqilin21.cn/2021/06/14/CSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C/"/>
    <id>https://me.miqilin21.cn/2021/06/14/CSS%20Flexbox%20%E5%AF%B9%E4%BD%A0%E8%AF%B4%E7%88%B1%E4%B8%8D%E5%AE%8C/</id>
    <published>2021-06-13T16:00:00.000Z</published>
    <updated>2021-12-16T03:08:33.396Z</updated>
    
    <content type="html"><![CDATA[<p>Flexbox 意为弹性布局，是一种新的 CSS 3 布局方式，与传统布局方式(基于盒模型，依赖 display 属性 +position 属性 +float 属性)相比，flex 布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。</p><p>废话就不多说了，下面我将尽可能地用简洁明了的言语来描述 Flex 布局。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/images/flex/1.jpg"></p><p>使用了 flex 布局，则有 flex 容器（flex container），子元素为项目(flex item）。</p><p>在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis)，start 和 end 表示对应轴的起始位置，这是默认的设置，当然你可以通过修改使垂直方向变为主轴，水平方向变为交叉轴。比如将 Flexbox 的方向设置为 row，则主轴就是横轴，而交叉轴就是纵轴；反之设置成 column，则主轴就是纵轴，而交叉轴就是横轴，这个下面会具体讲。</p><p>每个项目(flex item)占据的主轴空间为 (main size), 占据的交叉轴的空间为 (cross size)。</p><p>这里还需要注意的是，不能直截了当地认为宽度就是 main size，高度就是 cross size，这个还要取决于你主轴的方向，如果你垂直方向是主轴，那么项目的高度就是 main size。</p><p>实际上，要实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  display: flex | inline-flex; //可以有两种取值<br>&#125;<br></code></pre></td></tr></table></figure><p>给 div 这类块元素设置<code>display: flex</code>或者给 span 这类行内元素设<code>display: inline-flex</code>，flex 布局即创建！</p><p>而 Flex 布局相关属性正好分为两拨，一拨作用在 flex 容器上，还有一拨作用在 flex 子项上。</p><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 <code>float</code>、<code>clear</code>、<code>vertical-align</code> 的属性将会失效。</strong></p><h3 id="Flex-容器上的属性"><a href="#Flex-容器上的属性" class="headerlink" title="Flex 容器上的属性"></a>Flex 容器上的属性</h3><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p><strong>1. flex-direction: 决定主轴的方向(即项目的排列方向)</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>row</code>（默认）：主轴为水平方向，起点在左端</li></ul><p><img src="/images/flex/2.jpg"></p><ul><li><code>row-reverse</code>：主轴为水平方向，起点在右端</li></ul><p><img src="/images/flex/3.jpg"></p><ul><li><code>column</code>：主轴为垂直方向，起点在上沿</li></ul><p><img src="/images/flex/4.jpg"></p><ul><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿</li></ul><p><img src="/images/flex/5.jpg"></p><p><strong>2. flex-wrap: 决定容器内项目是否可换行</strong></p><p>默认情况下，项目都排在主轴线上，使用 <code>flex-wrap</code> 可实现项目的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>nowrap</code>（默认）：不换行，即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行</li></ul><p><img src="/images/flex/6.jpg"></p><ul><li><code>wrap</code>：项目主轴总尺寸超出容器时换行，第一行在上方</li></ul><p><img src="/images/flex/7.jpg"></p><ul><li><code>wrap-reverse</code>：换行并反向，第一行在下方</li></ul><p><img src="/images/flex/8.jpg"></p><p><strong>3. flex-flow: flex-direction 和 flex-wrap 的复合简写形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认值为: row nowrap，这个属性其实没多大卵用，不就是两个属性的缩写嘛。</p><p><strong>4. justify-content：定义项目在主轴的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>flex-start</code>（默认）：左对齐</li></ul><p><img src="/images/flex/9.jpg"></p><ul><li><code>flex-end</code>：右对齐</li></ul><p><img src="/images/flex/10.jpg"></p><ul><li><code>center</code>：居中</li></ul><p><img src="/images/flex/11.jpg"></p><ul><li><code>space-between</code>：两端对齐，项目之间的间隔相等，即剩余空间等分成间隙</li></ul><p><img src="/images/flex/12.jpg"></p><ul><li><code>space-around</code>：每个项目两侧的间隔相等，所以项目之间的间隔是项目与边缘的间隔的两倍</li></ul><p><img src="/images/flex/13.jpg"></p><p><strong>5. align-items: 定义项目在交叉轴上的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: stretch | flex-start | flex-end | center | baseline;<br>&#125;<br></code></pre></td></tr></table></figure><p>建立在主轴为水平方向时的测试，即 <code>flex-direction: row</code></p><ul><li><code>stretch</code>（默认）：如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度</li></ul><p><img src="/images/flex/14.jpg"></p><p>假设容器高度设置为 50px，而项目都没有设置高度或设为<code>auto</code>的情况下，则项目的高度也为 50px</p><ul><li><code>flex-start</code>：交叉轴的起点对齐</li></ul><p><img src="/images/flex/15.jpg"></p><ul><li><code>flex-end</code>：交叉轴的终点对齐</li></ul><p><img src="/images/flex/16.jpg"></p><ul><li><code>center</code>：交叉轴的中点对齐</li></ul><p><img src="/images/flex/17.jpg"></p><ul><li><code>baseline</code>: 项目的第一行文字的基线对齐</li></ul><p><img src="/images/flex/18.jpg"></p><p>以文字的底部为主</p><p><strong>6. align-content: 定义多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-content</span>: stretch | flex-start | flex-end | center | space-between |<br>    space-around;<br>&#125;<br></code></pre></td></tr></table></figure><p>什么叫项目只有一根轴线呢？其实可以这么理解：</p><p>当你 <code>flex-wrap</code> 设置为 <code>nowrap</code> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 <code>flex-wrap</code> 设置为 <code>wrap</code> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><p>建立在主轴为水平方向时测试，即 <code>flex-direction: row</code>, <code>flex-wrap: wrap</code></p><ul><li><code>stretch</code>（默认）：轴线占满整个交叉轴</li></ul><p><img src="/images/flex/19.jpg"></p><ul><li><code>flex-start</code>：轴线全部与交叉轴上的起点对齐</li></ul><p><img src="/images/flex/20.jpg"></p><ul><li><code>flex-end</code>：轴线全部与交叉轴上的终点对齐</li></ul><p><img src="/images/flex/21.jpg"></p><ul><li><code>center</code>：轴线全部在交叉轴上的中间对齐</li></ul><p><img src="/images/flex/22.jpg"></p><ul><li><code>space-between</code>：轴线与交叉轴两端对齐，轴线之间的间隔平均分布</li></ul><p><img src="/images/flex/23.jpg"></p><ul><li><code>space-around</code>：每个轴线两侧的间隔都相等，所以轴线之间的间隔是轴线与边缘的间隔的两倍</li></ul><p><img src="/images/flex/24.jpg"></p><p>到这里关于容器上的所有属性都讲完了，接下来就来讲讲关于在 flex item（项目） 上的属性。</p><h3 id="Flex-项目上的属性"><a href="#Flex-项目上的属性" class="headerlink" title="Flex 项目上的属性"></a>Flex 项目上的属性</h3><p>item 项目上有六种属性可运用，它们分别是：</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><strong>1. order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">order</span>: &lt;integer&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/flex/25.jpg"></p><p><strong>2. flex-grow: 定义项目的放大比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认值为 0，即如果存在剩余空间，也不放大。</p><p>如果所有项目的 <code>flex-grow</code> 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 <code>flex-grow</code> 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>3. flex-shrink: 定义项目的缩小比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p><p><img src="/images/flex/26.jpg"></p><p>如果所有项目的 <code>flex-shrink</code> 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code> 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><p><strong>4. flex-basis: 定义了在分配容器剩余空间之前项目的默认大小。相当于对浏览器提前告知：浏览器兄弟，我要占据这么大的空间，提前帮我预留好</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认值：<code>auto</code>，即项目本来的大小, 这时候 item 项目的宽高取决于 <code>width</code> 或 <code>height</code> 的值。</p><p>当主轴为水平方向的时候，同时设置 <code>width</code> 和 <code>flex-basis</code>，会忽略 <code>width</code>。flex 顾名思义就是弹性的意思，因此，实际上不建议对 flex 项目使用 <code>width</code> 属性，因为不够弹性。</p><p>当容器剩余空间不足的时候，flex 子项目的实际宽度通常不是设置的 <code>flex-basis</code> 尺寸，因为 flex 布局剩余空间不足的时候默认会收缩，如果有 3 个子项目，则默认按 1:1:1 收缩。</p><p><strong>5. flex: flex-grow, flex-shrink 和 flex-basis 的复合缩写</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: none | [ &lt; <span class="hljs-string">&quot;flex-grow&quot;</span> &gt; &lt; <span class="hljs-string">&quot;flex-shrink&quot;</span> &gt;? || &lt; <span class="hljs-string">&quot;flex-basis&quot;</span> &gt; ];<br>&#125;<br></code></pre></td></tr></table></figure><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值为<code>0 1 auto</code>。</p><p>有关快捷值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">flex: auto  //等同于flex:1 1 auto<br>flex: none  //等同于flex:0 0 auto<br></code></pre></td></tr></table></figure><p><strong>6. align-self: 控制单独某一个项目的垂直对齐方式，与 align-items 属性语法区别不大</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一区别就是<code>align-self</code>多了个<code>auto</code>（默认值），表示继承自 flex 容器的<code>align-items</code>属性值，如果没有父元素，则等同于 <code>stretch</code>。</p><p>跟 <code>align-items</code> 其他属性值含义一样，只不过 <code>align-self</code> 是对单个项目生效的，而 <code>align-items</code> 则是对容器下的所有项目生效的。</p><h3 id="从垂直居中看出-flex-的强大"><a href="#从垂直居中看出-flex-的强大" class="headerlink" title="从垂直居中看出 flex 的强大"></a>从垂直居中看出 flex 的强大</h3><p>以往让元素垂直居中并不容易，直到 CSS3 的出现，使用绝对定位配合<code>translate</code>属性才让垂直居中变得简单，不过还有一个更爽的办法，那就是使用 flex，让垂直居中变得异常简单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;“wrapper”&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;“div”&quot;</span>&gt;</span>flexbox 对你说爱不完<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>几行简单代码，即可让 div 垂直居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里最重要的就是包裹元素的三个关键属性:</p><ul><li><code>display: flex</code> 将容器指定为 flex 布局，任何一个元素都可以指定</li><li><code>align-items: center</code> 沿交叉轴对齐项目，这里指的是垂直方向</li><li><code>justify-content: center</code> 设置主轴内容对齐方式</li></ul><h3 id="其他-Flex-知识点"><a href="#其他-Flex-知识点" class="headerlink" title="其他 Flex 知识点"></a>其他 Flex 知识点</h3><ul><li>在 Flex 布局中，再强调一遍 flex 子元素中设置<code>float</code>，<code>clear</code>以及<code>vertical-align</code>属性都是没有用的。</li><li>Flexbox 布局最适合应用程序的组件和小规模布局（一维布局），而 Grid 布局则适用于更大规模的布局（二维布局），有关 Grid 布局的文章后面会补充。</li><li>已经 9102 年了，Flex 老语法不用在管了，果断放弃，然后私有前缀也不用再加了，看到就烦。</li><li>如果想更好地理解 Flex 的工作原理，可以在此页面上尝试<a href="http://www.csstutorial.org/flex-both.html">flex 布局编辑器</a>。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Flexbox 意为弹性布局，是一种新的 CSS 3 布局方式，与传统布局方式(基于盒模型，依赖 display 属性 +position 属性 +float 属性)相比，flex 布局更加灵活，具有响应式，可以解决在布局上的很多麻烦。&lt;/p&gt;
&lt;p&gt;废话就不多说了，下面我</summary>
      
    
    
    
    <category term="CSS" scheme="https://me.miqilin21.cn/categories/CSS/"/>
    
    
    <category term="CSS" scheme="https://me.miqilin21.cn/tags/CSS/"/>
    
    <category term="布局" scheme="https://me.miqilin21.cn/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之闭包</title>
    <link href="https://me.miqilin21.cn/2021/06/02/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/"/>
    <id>https://me.miqilin21.cn/2021/06/02/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AD%E5%8C%85(Closure)/</id>
    <published>2021-06-01T16:00:00.000Z</published>
    <updated>2021-12-16T03:08:44.751Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多初学者在学习 JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。</p><p>在具体介绍闭包之前，为了更好的理解本文要介绍的内容，建议先去阅读前面的文章<a href="https://zhuanlan.zhihu.com/p/69142071">《JavaScript 系列之变量对象》</a>和<a href="https://zhuanlan.zhihu.com/p/69910449">《JavaScript 系列之作用域和作用域链》</a>，因为它们相互之间都是有关联的。</p><h3 id="闭包是什么？"><a href="#闭包是什么？" class="headerlink" title="闭包是什么？"></a>闭包是什么？</h3><p>首先，先来看看 MDN 对闭包的定义：</p><blockquote><p>闭包是指那些能够访问自由变量的函数。</p></blockquote><p>那什么是自由变量呢？</p><blockquote><p>自由变量是一个既不是函数的形参，也不是函数的局部变量的变量。</p></blockquote><p>由此，我们可以看出闭包共有两部分组成：</p><blockquote><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>好，如果上面三行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 不过如果你是初学者的话，我想应该不会，如果仅用三言两语就把闭包讲通，那还能称为 Javascript 语言的一个难点吗？</p><p>先来举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(n); <span class="hljs-comment">// 1</span><br>&#125;<br><br>f1();<br></code></pre></td></tr></table></figure><p><code>f1</code> 函数可以访问变量 <code>n</code>，但是 <code>n</code> 既不是 <code>f1</code> 函数的形参，也不是 <code>f1</code> 函数的局部变量，所以这种情况下的 <code>n</code> 就是自由变量。其实上面代码中就存在闭包了，即函数 <code>f1</code> + <code>f1</code> 函数访问的自由变量 <code>n</code> 就构成了一个<strong>闭包</strong>。</p><p>上面代码中，函数 <code>f1</code> 可以读取全局自由变量 <code>n</code>。但是，函数外部无法读取函数内部声明的变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(n); <span class="hljs-comment">// Uncaught ReferenceError: n is not defined</span><br></code></pre></td></tr></table></figure><p>如果有时需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过改变形式才能实现。那就是在函数的内部，再定义一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(n); <span class="hljs-comment">// 1</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> f2;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = f1();<br>a();<br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们就可以在<code>f1</code>外部读取它的内部变量了。</p><p>所以<strong>闭包是一个可以从另一个函数的作用域访问变量的函数。这是通过在函数内创建函数来实现的。当然，外部函数无法访问内部范围</strong>。</p><p>在我们深入研究闭包之前，有必要先从不使用闭包的情况切入，了解为什么要用闭包。</p><h3 id="不使用闭包的情况"><a href="#不使用闭包的情况" class="headerlink" title="不使用闭包的情况"></a>不使用闭包的情况</h3><p>在 JavaScript 中，全局变量的错用可能会使得我们的代码出现不可预期的错误。</p><p>假设我们现在要做一个计数的函数，一开始我们想要先写一个给狗的计数函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 狗的计数函数</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDogs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  count += <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; dog(s)&quot;</span>);<br>&#125;<br><br>countDogs(); <span class="hljs-comment">// 1 dog(s)</span><br>countDogs(); <span class="hljs-comment">// 2 dog(s)</span><br>countDogs(); <span class="hljs-comment">// 3 dog(s)</span><br></code></pre></td></tr></table></figure><p>接着继续写代码的其他部分，当写到后面时，我发现我也需要写猫的计数函数，于是我又开始写了猫的计数函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 狗的计数函数</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDogs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  count += <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; dog(s)&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 中间的其它代码...</span><br><br><span class="hljs-comment">// 猫的计数函数</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countCats</span>(<span class="hljs-params"></span>) </span>&#123;<br>  count += <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; cat(s)&quot;</span>);<br>&#125;<br><br>countCats(); <span class="hljs-comment">// 1 cat(s)</span><br>countCats(); <span class="hljs-comment">// 2 cat(s)</span><br>countCats(); <span class="hljs-comment">// 3 cat(s)</span><br></code></pre></td></tr></table></figure><p>乍看之下好像没啥问题，当我执行<code>countDogs()</code>或<code>countCats()</code>，都会让<code>count</code>增加，然而问题在于当我在不注意的情况下把<code>count</code>这个变量建立在了全局作用域底下时，不论是执行<code>countDogs()</code>或是<code>countCats()</code>时，都是用到了全局的<code>count</code>变量，这使得当我执行下面的代码时，它没有办法分辨现在到底是在对狗计数还是对猫计数，进而导致把猫的数量和狗的数量交错计算的错误情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">countCats(); <span class="hljs-comment">// 1 cat(s)</span><br>countCats(); <span class="hljs-comment">// 2 cat(s)</span><br>countCats(); <span class="hljs-comment">// 3 cat(s)</span><br><br>countDogs(); <span class="hljs-comment">// 4 dog(s)，我希望是 1 dog(s)</span><br>countDogs(); <span class="hljs-comment">// 5 dog(s)，我希望是 2 dog(s)</span><br><br>countCats(); <span class="hljs-comment">// 6 cat(s)，我希望是 4 cat(s)</span><br></code></pre></td></tr></table></figure><h3 id="闭包让函数有私有变量"><a href="#闭包让函数有私有变量" class="headerlink" title="闭包让函数有私有变量"></a>闭包让函数有私有变量</h3><p>从上面的例子我们知道，如果错误的使用全局变量，很容易会出现一些莫名其妙的 bug ，这时候我们就可以利用闭包（closure）的写法，让函数有自己私有变量，简单来说就是<code>countDogs</code>里面能有一个计算<code>dogs</code>的<code>count</code>变数；而<code>countCats</code>里面也能有一个计算<code>cats</code>的<code>count</code>变量，两者是不会互相干扰的。</p><p>为了达到这样的效果，我们就要利用闭包，让变量保留在该函数中而不会被外在环境干扰。</p><p>改成闭包的写法会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogHouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDogs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; dogs&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> countDogs;<br>&#125;<br><br><span class="hljs-keyword">const</span> countDogs = dogHouse();<br>countDogs(); <span class="hljs-comment">// &quot;1 dogs&quot;</span><br>countDogs(); <span class="hljs-comment">// &quot;2 dogs&quot;</span><br>countDogs(); <span class="hljs-comment">// &quot;3 dogs&quot;</span><br></code></pre></td></tr></table></figure><p>这样我们就将专门计算狗的变量<code>count</code>闭包在<code>dogHouse</code>这个函数中，在<code>dogHouse</code>这个函数中里面的<code>countDogs()</code>才是我们真正执行计数的函数，而在<code>dogHouse</code>这个函数中存在<code>count</code>这个变量，由于 JavaScript 变量会被缩限在函数的执行上下文中，因此这个<code>count</code>的值只有在<code>dogHouse</code>里面才能被取用，在<code>dogHouse</code>函数外是取用不到这个值的。</p><p>接着因为我们要能够执行在<code>dogHouse</code>中真正核心<code>countDogs()</code>这个函数，因此我们会在最后把这个函数给 return 出来，好让我们可以在外面去调用到<code>dogHouse</code>里面的这个<code>countDogs()</code>函数。</p><p>最后当我们在使用闭包时，我们先把存在<code>dogHouse</code>里面的<code>countDogs</code>拿出来用，并一样命名为<code>countDogs</code>（这里变量名称可以自己取），因此当我执行全局中的<code>countDogs</code>时，实际上会执行的是<code>dogHouse</code>里面的<code>countDogs</code>函数。</p><p>上面这是闭包的基本写法：<strong>一个函数里面包了另一个函数，同时会 return 里面的函数让我们可以在外面使用到它</strong>。</p><p>我们可以把我们最一开始的代码都改成使用闭包的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogHouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDogs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; dogs&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> countDogs;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catHouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countCats</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; cats&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> countCats;<br>&#125;<br><br><span class="hljs-keyword">const</span> countDogs = dogHouse();<br><span class="hljs-keyword">const</span> countCats = catHouse();<br><br>countDogs(); <span class="hljs-comment">// &quot;1 dogs&quot;</span><br>countDogs(); <span class="hljs-comment">// &quot;2 dogs&quot;</span><br>countDogs(); <span class="hljs-comment">// &quot;3 dogs&quot;</span><br><br>countCats(); <span class="hljs-comment">// &quot;1 cats&quot;</span><br>countCats(); <span class="hljs-comment">// &quot;2 cats&quot;</span><br><br>countDogs(); <span class="hljs-comment">// &quot;4 dogs&quot;</span><br></code></pre></td></tr></table></figure><p>当我们正确地使用闭包时，虽然一样都是使用<code>count</code>来计数，但是是在不同执行环境内的<code>count</code>因此也不会相互干扰。</p><h3 id="进一步了解和使用闭包"><a href="#进一步了解和使用闭包" class="headerlink" title="进一步了解和使用闭包"></a>进一步了解和使用闭包</h3><p>另外，甚至在运用的是同一个<code>dogHouse</code> 时，变量间也都是独立的执行环境不会干扰，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogHouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDogs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; dogs&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> countDogs;<br>&#125;<br><br><span class="hljs-comment">// 虽然都是使用 dogHouse ，但是各是不同的执行环境</span><br><span class="hljs-comment">// 因此彼此的变量不会互相干扰</span><br><br><span class="hljs-keyword">var</span> countGolden = dogHouse();<br><span class="hljs-keyword">var</span> countPug = dogHouse();<br><span class="hljs-keyword">var</span> countPuppy = dogHouse();<br><br>countGolden(); <span class="hljs-comment">// 1 dogs</span><br>countGolden(); <span class="hljs-comment">// 2 dogs</span><br><br>countPug(); <span class="hljs-comment">// 1 dogs</span><br>countPuppy(); <span class="hljs-comment">// 1 dogs</span><br><br>countGolden(); <span class="hljs-comment">// 3 dogs</span><br>countPug(); <span class="hljs-comment">// 2 dogs</span><br></code></pre></td></tr></table></figure><h3 id="将参数代入闭包中"><a href="#将参数代入闭包中" class="headerlink" title="将参数代入闭包中"></a>将参数代入闭包中</h3><p>但是这么做的话你可能觉得还不够清楚，因为都是叫做<code>dogs</code>，这时候我们一样可以把外面的变量通过函数的参数代入闭包中，像是下面这样，返回的结果就清楚多了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过函数的参数将值代入闭包中</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogHouse</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countDogs</span>(<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; &quot;</span> + name);<br>  &#125;<br>  <span class="hljs-keyword">return</span> countDogs;<br>&#125;<br><br><span class="hljs-comment">// 同样是使用 dogHouse 但是使用不同的参数</span><br><span class="hljs-keyword">var</span> countGolden = dogHouse(<span class="hljs-string">&quot;Golden&quot;</span>);<br><span class="hljs-keyword">var</span> countPug = dogHouse(<span class="hljs-string">&quot;Pug&quot;</span>);<br><span class="hljs-keyword">var</span> countPuppy = dogHouse(<span class="hljs-string">&quot;Puppy&quot;</span>);<br><br><span class="hljs-comment">// 结果看起来更清楚了</span><br>countGolden(); <span class="hljs-comment">// 1 Golden</span><br>countGolden(); <span class="hljs-comment">// 2 Golden</span><br><br>countPug(); <span class="hljs-comment">// 1 Pug</span><br>countPuppy(); <span class="hljs-comment">// 1 Puppy</span><br><br>countGolden(); <span class="hljs-comment">// 3 Golden</span><br>countPug(); <span class="hljs-comment">// 2 Pug</span><br></code></pre></td></tr></table></figure><p>为了进一步简化代码，我们可以在闭包中直接 return 一个函数出来，我们就可以不必为里面的函数命名了，而是用匿名函数的方式直接把它返回出来。</p><p>因此写法可以简化成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogHouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 把原本 countDogs 函数改成匿名函数直接放进来</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; dogs&quot;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catHouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 把原本 countCats 函数改成匿名函数直接放进来</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    count += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; cats&quot;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们刚刚有提到，可以透过函数参数的方式把值代入闭包当中，因此实际上我们只需要一个 counter ，在不同的时间点给它参数区分就好。这样子不管你是要记录哪一种动物都很方便了，而且代码也相当简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCounter</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    count++;<br>    <span class="hljs-built_in">console</span>.log(count + <span class="hljs-string">&quot; &quot;</span> + name);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> dogCounter = createCounter(<span class="hljs-string">&quot;dogs&quot;</span>);<br><span class="hljs-keyword">const</span> catCounter = createCounter(<span class="hljs-string">&quot;cats&quot;</span>);<br><span class="hljs-keyword">const</span> pigCounter = createCounter(<span class="hljs-string">&quot;pigs&quot;</span>);<br><br>dogCounter(); <span class="hljs-comment">// 1 dogs</span><br>dogCounter(); <span class="hljs-comment">// 2 dogs</span><br>catCounter(); <span class="hljs-comment">// 1 cats</span><br>catCounter(); <span class="hljs-comment">// 2 cats</span><br>pigCounter(); <span class="hljs-comment">// 1 pigs</span><br>dogCounter(); <span class="hljs-comment">// 3 dogs</span><br>catCounter(); <span class="hljs-comment">// 3 cats</span><br></code></pre></td></tr></table></figure><h3 id="闭包的实际应用"><a href="#闭包的实际应用" class="headerlink" title="闭包的实际应用"></a>闭包的实际应用</h3><p>我们要实现这样的一个需求：点击某个按钮，提示点击的是”第 n 个”按钮，此处我们先不用事件代理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.....<br>&lt;button&gt;测试<span class="hljs-number">1</span>&lt;/button&gt;<br>&lt;button&gt;测试<span class="hljs-number">2</span>&lt;/button&gt;<br>&lt;button&gt;测试<span class="hljs-number">3</span>&lt;/button&gt;<br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>   <span class="hljs-keyword">var</span> buttons = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buttons.length; i++) &#123;<br>      buttons[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第&#x27;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;个&#x27;</span>)<br>      &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这时候可能会预期点选不同的按钮时，会根据每个 button 点击顺序的不同而得到不同的结果。但是实际执行后，你会发现返回的结果都是“第四个”。这是因为<code>i</code>是全局变量，执行到点击事件时，此时<code>i</code>的值为 3。</p><p>如果要强制返回预期的结果，那该如何修改呢？最简单的是用<code>let</code>声明<code>i</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; buttons.length; i++) &#123;<br>  buttons[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个&quot;</span>);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说，通过<code>let</code>可以帮我们把所定义的变量缩限在块级作用域中，也就是变量的作用域只有在<code>&#123; &#125;</code>内，来避免 <code>i</code> 这个变量跑到全局变量被重复覆盖。</p><p>另外我们可以通过闭包的方式来修改:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; buttons.length; i++) &#123;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) </span>&#123;<br>    buttons[j].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;第&quot;</span> + (j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个&quot;</span>);<br>    &#125;;<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>这其实也是「立即执行函数表达式 (Immediately Invoked Function Expression, IIFE)」的概念，后续会有专门的文章进行介绍。</p><p>希望看完这篇文章后，你能对于闭包有更清楚的认识。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信很多初学者在学习 JavaScript 的时候，一直对闭包(closure) 有所疑惑。因为从字面上来看，完全看不出它所代表的东西。那么今天，我想通过这篇文章，尽量用简单易懂的话来与各位介绍「闭包」到底是什么。&lt;/p&gt;
&lt;p&gt;在具体介绍闭包之前，为了更好的理解本文要介绍</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="闭包" scheme="https://me.miqilin21.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之this是什么</title>
    <link href="https://me.miqilin21.cn/2021/05/24/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://me.miqilin21.cn/2021/05/24/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8Bthis%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2021-05-23T16:00:00.000Z</published>
    <updated>2021-12-16T03:08:56.411Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://zhuanlan.zhihu.com/p/69910449">《JavaScript 系列之作用域和作用域链》</a>中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。</p><p>再来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain/1.jpg"></p><p>本章将专门介绍与执行上下文创建阶段直接相关的最后一个细节——<strong>this</strong>是什么？以及它的指向到底是什么。</p><h3 id="了解-this"><a href="#了解-this" class="headerlink" title="了解 this"></a>了解 this</h3><p>也许你在其他面向对象的编程语言曾经看过<code>this</code>，也知道它会指向某个构造器(constructor)所建立的对象。但事实上在 JavaScript 里面，<code>this</code>所代表的不仅仅是那个被建立的对象。</p><p>先来看看 ECMAScript 标准规范对 this 的定义：</p><blockquote><p>「The this keyword evaluates to the value of the ThisBinding of the current execution context.」<br>「this 这个关键字代表的值为当前执行上下文的 ThisBinding。」</p></blockquote><p>然后再来看看 MDN 对 this 的定义：</p><blockquote><p>「In most cases, the value of this is determined by how a function is called.」<br>「在大多数的情况下，this 其值取决于函数的调用方式。」</p></blockquote><p>好，如果上面两行就看得懂的话那么就不用再往下看了，Congratulations！</p><p>…… 我想应该不会，至少我光看这两行还是不懂。</p><p>先来看个例子吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> getGender = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> people1.gender;<br>&#125;;<br><br><span class="hljs-keyword">var</span> people1 = &#123;<br>  gender: <span class="hljs-string">&quot;female&quot;</span>,<br>  getGender: getGender,<br>&#125;;<br><br><span class="hljs-keyword">var</span> people2 = &#123;<br>  gender: <span class="hljs-string">&quot;male&quot;</span>,<br>  getGender: getGender,<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(people1.getGender()); <span class="hljs-comment">// female</span><br><span class="hljs-built_in">console</span>.log(people2.getGender()); <span class="hljs-comment">// female</span><br></code></pre></td></tr></table></figure><p>what?怎么<code>people2</code>变性了呢，这不是我想要的结果啊，为什么呢？</p><p>因为<code>getGender()</code>返回(return)写死了<code>people1.gender</code>的关系，结果自然是’female’。</p><p>那么，如果我们把<code>getGender</code>稍改一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> getGender = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.gender;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个时候，你应该会分别得到<code>female</code>与<code>male</code>两种结果。</p><p>所以回到前面讲的重点，从这个例子可以看出，即便<code>people1</code>与<code>people2</code>的<code>getGender</code>方法参照的都是同一个<code>getGender function</code>，但由于调用的对象不同，所以执行的结果也会不同。</p><p>现在我们知道了第一个重点，**<code>this</code>实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数的调用方式**。如何的区分<code>this</code>呢？</p><h3 id="this-到底是谁"><a href="#this-到底是谁" class="headerlink" title="this 到底是谁"></a>this 到底是谁</h3><p>看完上面的例子，还是有点似懂非懂吧？那接下来我们来看看不同的调用方式对 <code>this</code> 值的影响。</p><h4 id="情况一：全局对象-amp-调用普通函数"><a href="#情况一：全局对象-amp-调用普通函数" class="headerlink" title="情况一：全局对象&amp;调用普通函数"></a>情况一：全局对象&amp;调用普通函数</h4><p>在全局环境中，<code>this</code> 指向全局对象，在浏览器中，它就是 <code>window</code> 对象。下面的示例中，无论是否是在严格模式下，<code>this</code> 都是指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x === x); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果普通函数是在全局环境中被调用，在非严格模式下，普通函数中 <code>this</code> 也指向全局对象；如果是在严格模式下，<code>this</code> 将会是 <code>undefined</code>。ES5 为了使 JavaScript 运行在更有限制性的环境而添加了严格模式，严格模式为了消除安全隐患，禁止了 <code>this</code> 关键字指向全局对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Window 全局对象</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); <span class="hljs-comment">// 1</span><br>&#125;<br><br>fn();<br></code></pre></td></tr></table></figure><p>使用严格模式后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>; <span class="hljs-comment">// 使用严格模式</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// undefined</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); <span class="hljs-comment">// 报错 &quot;Cannot read property &#x27;x&#x27; of undefined&quot;，因为此时 this 是 undefined</span><br>&#125;<br><br>fn();<br></code></pre></td></tr></table></figure><h4 id="情况二：作为对象方法的调用"><a href="#情况二：作为对象方法的调用" class="headerlink" title="情况二：作为对象方法的调用"></a>情况二：作为对象方法的调用</h4><p>我们知道，在对象里的值如果是原生值（primitive type；例如，字符串、数值、布尔值），我们会把这个新建立的东西称为「<strong>属性（property）</strong>」；如果对象里面的值是函数（function）的话，我们则会把这个新建立的东西称为「<strong>方法（method）</strong>」。</p><p>如果函数作为对象的一个方法时，并且作为对象的一个方法被调用时，<strong>函数中的<code>this</code>指向这个上一级对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  fn: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;,<br>&#125;;<br><br>obj.fn();<br><br><span class="hljs-comment">// obj.fn()结果打印出;</span><br><span class="hljs-comment">// Object &#123;x: 2, fn: function&#125;</span><br><span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">var</span> a = obj.fn;<br>a();<br><br><span class="hljs-comment">// a()结果打印出:</span><br><span class="hljs-comment">// Window 全局对象</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，直接运行 <code>obj.fn()</code> ，调用该函数的上一级对象是 <code>obj</code>，所以 <code>this</code> 指向 <code>obj</code>，得到 <code>this.x</code> 的值是 2；之后我们将 <code>fn</code> 方法首先赋值给变量 <code>a</code>，<code>a</code> 运行在全局环境中，所以此时 <code>this</code> 指向全局对象<code>Window</code>，得到 <code>this.x</code> 为 1。</p><p>我们再来看一个例子，如果函数被多个对象嵌套调用，this 会指向什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: &#123;<br>    x: <span class="hljs-number">3</span>,<br>    fn: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Object &#123;x: 3, fn: function&#125;</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); <span class="hljs-comment">// 3</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><br>obj.y.fn();<br></code></pre></td></tr></table></figure><p>为什么结果不是 2 呢，因为在这种情况下记住一句话：**<code>this</code> 始终会指向直接调用函数的上一级对象**，即 <code>y</code>，上面例子实际执行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> y = &#123;<br>  x: <span class="hljs-number">3</span>,<br>  fn: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Object &#123;x: 3, fn: function&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x); <span class="hljs-comment">// 3</span><br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: y,<br>&#125;;<br><br>obj.y.fn();<br></code></pre></td></tr></table></figure><p>对象可以嵌套，函数也可以，如果函数嵌套，<code>this</code> 会有变化吗？我们通过下面代码来探讨一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Object &#123;y: function&#125;</span><br>    fn();<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// false</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Window 全局对象</span><br>    &#125;<br>  &#125;,<br>&#125;;<br><br>obj.y();<br></code></pre></td></tr></table></figure><p>在函数 <code>y</code> 中，<code>this</code> 指向了调用它的上一级对象 <code>obj</code>，这是没有问题的。但是在嵌套函数 <code>fn</code> 中，<code>this</code> 并不指向 <code>obj</code>。嵌套的函数不会从调用它的函数中继承 <code>this</code>，当嵌套函数作为函数调用时，其 <code>this</code> 值在非严格模式下指向全局对象，在严格模式是 <code>undefined</code>，所以上面例子实际执行的是下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// false</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Window 全局对象</span><br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Object &#123;y: function&#125;</span><br>    fn();<br>  &#125;,<br>&#125;;<br><br>obj.y();<br></code></pre></td></tr></table></figure><h4 id="情况三：作为构造函数调用"><a href="#情况三：作为构造函数调用" class="headerlink" title="情况三：作为构造函数调用"></a>情况三：作为构造函数调用</h4><p>我们可以使用 <code>new</code> 关键字，通过构造函数生成一个实例对象。此时，**<code>this</code> 便指向这个新对象**。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Fn &#123;x: 2&#125;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Fn(); <span class="hljs-comment">// obj和Fn(..)调用中的this进行绑定</span><br><span class="hljs-built_in">console</span>.log(obj.x); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>使用<code>new</code>来调用<code>Fn(..)</code>时，会构造一个新对象并把它（<code>obj</code>）绑定到<code>Fn(..)</code>调用中的<code>this</code>。还有值得一提的是，如果构造函数返回了非引用类型（<code>string</code>，<code>number</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>），<code>this</code> 仍然指向实例化的新对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    x: <span class="hljs-number">3</span>,<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Fn();<br><br><span class="hljs-built_in">console</span>.log(a.x); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>因为<code>Fn()</code>返回(return)的是一个对象（引用类型），<code>this</code> 会指向这个 return 的对象。如果 return 的是一个非引用类型的值呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Fn();<br><br><span class="hljs-built_in">console</span>.log(a.x); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="情况四：call-和-apply-方法调用"><a href="#情况四：call-和-apply-方法调用" class="headerlink" title="情况四：call 和 apply 方法调用"></a>情况四：call 和 apply 方法调用</h4><p>如果你想改变 <code>this</code> 的指向，可以使用 <code>call</code> 或 <code>apply</code> 方法。<strong>它们的第一个参数都是指定函数运行时其中的<code>this</code>指向</strong>。如果第一个参数不传（参数为空）或者传 <code>null</code> 、<code>undefined</code>，默认 <code>this</code> 指向全局对象（非严格模式）或 <code>undefined</code>（严格模式）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br><br>fn.call(obj);<br><span class="hljs-comment">// Object &#123;x: 2&#125;</span><br><span class="hljs-comment">// 2</span><br><br>fn.apply(obj);<br><span class="hljs-comment">// Object &#123;x: 2&#125;</span><br><span class="hljs-comment">// 2</span><br><br>fn.call();<br><span class="hljs-comment">// Window 全局对象</span><br><span class="hljs-comment">// 1</span><br><br>fn.apply(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">// Window 全局对象</span><br><span class="hljs-comment">// 1</span><br><br>fn.call(<span class="hljs-literal">undefined</span>);<br><span class="hljs-comment">// Window 全局对象</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>使用 <code>call</code> 和 <code>apply</code> 时，如果给 <code>this</code> 传的不是对象，JavaScript 会使用相关构造函数将其转化为对象，比如传 <code>number</code> 类型，会进行<code>new Number()</code>操作，如传 <code>string</code> 类型，会进行<code>new String()</code>操作，如传 <code>boolean</code> 类型，会进行<code>new Boolean()</code>操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">this</span>));<br>&#125;<br><br>fn.call(<span class="hljs-string">&quot;love&quot;</span>); <span class="hljs-comment">// [object String]</span><br>fn.apply(<span class="hljs-number">1</span>); <span class="hljs-comment">// [object Number]</span><br>fn.call(<span class="hljs-literal">true</span>); <span class="hljs-comment">// [object Boolean]</span><br></code></pre></td></tr></table></figure><p><code>call</code> 和 <code>apply</code> 的区别在于，<code>call</code> 的第二个及后续参数是一个参数列表，<code>apply</code> 的第二个参数是数组。参数列表和参数数组都将作为函数的参数进行执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sum</span>(<span class="hljs-params">y, z</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + y + z);<br>&#125;<br><br>Sum.call(obj, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 9</span><br>Sum.apply(obj, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h4 id="情况五：bind-方法调用"><a href="#情况五：bind-方法调用" class="headerlink" title="情况五：bind 方法调用"></a>情况五：bind 方法调用</h4><p>调用 <code>f.bind(someObject)</code> 会创建一个与 <code>f</code> 具有相同函数体和作用域的函数，但是在这个新函数中，新函数的 <code>this</code> <strong>会永久的指向 <code>bind</code> 传入的第一个参数</strong>，无论这个函数是如何被调用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>  x: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = &#123;<br>  x: <span class="hljs-number">3</span>,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br><br><span class="hljs-keyword">var</span> a = fn.bind(obj1);<br><span class="hljs-keyword">var</span> b = a.bind(obj2);<br><br>fn();<br><span class="hljs-comment">// Window 全局对象</span><br><span class="hljs-comment">// 1</span><br><br>a();<br><span class="hljs-comment">// Object &#123;x: 2&#125;</span><br><span class="hljs-comment">// 2</span><br><br>b();<br><span class="hljs-comment">// Object &#123;x: 2&#125;</span><br><span class="hljs-comment">// 2</span><br><br>a.call(obj2);<br><span class="hljs-comment">// Object &#123;x: 2&#125;</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，虽然我们尝试给函数 <code>a</code> 重新指定 <code>this</code> 的指向，但是它依旧指向第一次 <code>bind</code> 传入的对象，即使是使用 <code>call</code> 或 <code>apply</code> 方法也不能改变这一事实，即永久的指向 <code>bind</code> 传入的第一次参数。</p><h4 id="情况六：箭头函数中-this-指向"><a href="#情况六：箭头函数中-this-指向" class="headerlink" title="情况六：箭头函数中 this 指向"></a>情况六：箭头函数中 this 指向</h4><p>值得一提的是，从 ES6 开始新增了箭头函数，先来看看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">MDN 上对箭头函数的说明</a>：</p><blockquote><p>An arrow function expression has a shorter syntax than a function expression and does notbind its own <code>this</code>,<code>arguments</code>,<code>super</code>, or <code>new.target</code>. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors.</p></blockquote><p>这里已经清楚了说明了，箭头函数没有自己的<code>this</code>绑定。**箭头函数中使用的<code>this</code>，其实是直接包含它的那个函数或函数表达式中的<code>this</code>**。在前面情况二中函数嵌套函数的例子中，被嵌套的函数不会继承上层函数的 <code>this</code>，如果使用箭头函数，会发生什么变化呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// true</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Object &#123;y: function&#125;</span><br><br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// true</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Object &#123;y: function&#125;</span><br>    &#125;;<br>    fn();<br>  &#125;,<br>&#125;;<br><br>obj.y();<br></code></pre></td></tr></table></figure><p>和普通函数不一样，箭头函数中的 <code>this</code> 指向了 <code>obj</code>，这是因为它从上一层的函数中继承了 <code>this</code>，你可以理解为箭头函数修正了 <code>this</code> 的指向。所以**箭头函数的<code>this</code>不是调用的时候决定的，而是在定义的时候处在的对象就是它的<code>this</code>**。</p><p>换句话说，箭头函数的<code>this</code>看外层的是否有函数，如果有，外层函数的<code>this</code>就是内部箭头函数的<code>this</code>，如果没有，则<code>this</code>是<code>Window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  y: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// false</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Window 全局对象</span><br><br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === obj); <span class="hljs-comment">// false</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// Window 全局对象</span><br>    &#125;;<br>    fn();<br>  &#125;,<br>&#125;;<br><br>obj.y();<br></code></pre></td></tr></table></figure><p>上例中，虽然存在两个箭头函数，其实<code>this</code>取决于最外层的箭头函数，由于<code>obj</code>是个对象而非函数，所以<code>this</code>指向为<code>Window</code>全局对象。</p><p>同 bind 一样，箭头函数也很“顽固”，我们无法通过 <code>call</code> 和 <code>apply</code> 来改变 <code>this</code> 的指向，即传入的第一个参数被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;;<br><br>a.call(obj);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// Window 全局对象</span><br><br>a.apply(obj);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// Window 全局对象</span><br></code></pre></td></tr></table></figure><p>文字描述有点过多可能有点干涩，那么就看底下的这张流程图吧，我觉得这个图总结的很好（转自掘金小册-<a href="https://juejin.im/book/5bdc715fe51d454e755f75ef">前端面试之道</a>），图中的流程只针对于单个规则。</p><p><img src="/images/this/1.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章介绍了 <code>this</code> 指向的几种情况，不同的运行环境和调用方式都会对 <code>this</code> 产生影响。总的来说，函数 <code>this</code> 的指向取决于当前调用该函数的对象，也就是执行时的对象。在这一节中，你需要掌握：</p><ul><li><code>this</code> 指向全局对象的情况；</li><li>严格模式和非严格模式下 <code>this</code> 的区别；</li><li>函数作为对象的方法调用时 <code>this</code> 指向的几种情况；</li><li>作为构造函数时 <code>this</code> 的指向，以及是否 <code>return</code> 的区别；</li><li>使用 <code>call</code> 和 <code>apply</code> 改变调用函数的对象；</li><li><code>bind</code> 创建的函数中 <code>this</code> 的指向；</li><li>箭头函数中的 <code>this</code> 指向。</li></ul><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69910449&quot;&gt;《JavaScript 系列之作用域和作用域链》&lt;/a&gt;中，了解到了执行上下文创建阶段的作用域链(Scope chain)，在这篇文章里，我们将讨论跟执行上下文直接相关的更</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="this" scheme="https://me.miqilin21.cn/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之作用域和作用域链</title>
    <link href="https://me.miqilin21.cn/2021/05/18/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>https://me.miqilin21.cn/2021/05/18/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</id>
    <published>2021-05-17T16:00:00.000Z</published>
    <updated>2021-12-16T03:12:54.498Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://zhuanlan.zhihu.com/p/69142071">《JavaScript 系列之变量对象》</a>中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。</p><p>此外，我们也知道每次进入上下文时都会创建变量对象并填充初始值，并且值会在代码执行阶段进行更新，现在就对执行上下文做更深一步的了解。</p><p>先来回顾一下关于执行上下文的三个阶段生命周期：</p><p><img src="/images/scopechain/1.jpg"></p><p>本章将专门介绍与执行上下文创建阶段直接相关的另一个细节——<strong>作用域链</strong>。</p><h3 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h3><p>在介绍作用域链前，有必要先来了解一下被称为作用域(Scope)的特性，那什么是作用域呢？</p><p>作用域就是在运行时代码中不同部分中函数和变量的可访问性。可能这句话并不太好理解，我们先来看段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> inVariable = <span class="hljs-string">&quot;inner variable&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">// inner variable</span><br>&#125;<br><br>fn();<br><span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">// Uncaught ReferenceError: inVariable is not defined</span><br></code></pre></td></tr></table></figure><p>从上面的代码中我们可以很直观地体会作用域的概念，变量<code>inVariable</code>在全局作用域没有声明，所以在全局作用域下直接取值会报错。所以我们可以这样理解：<strong>作用域就像一个地头蛇，我的地盘我做主，让属于自己域内的变量不会轻易外泄出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</strong>。这几句话总比前面那句好理解多了吧。</p><p>关于 JavaScript 中的作用域类型，<strong>ES6 之前 JavaScript 并没有块级作用域，只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现：</p><ul><li>全局作用域  —  变量可以随处访问</li><li>函数作用域—  变量可以在定义它们的函数的边界内访问</li><li>块级作用域—变量可以在定义它们的块中访问，块由 { 和 } 分隔</li></ul><h3 id="全局作用域和函数作用域"><a href="#全局作用域和函数作用域" class="headerlink" title="全局作用域和函数作用域"></a>全局作用域和函数作用域</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">global</span> = <span class="hljs-string">&quot;global scoped&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">global</span> = <span class="hljs-string">&quot;function scoped&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">global</span>); <span class="hljs-comment">// function scoped</span><br>&#125;<br><br>fn();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">global</span>); <span class="hljs-comment">// global scoped</span><br></code></pre></td></tr></table></figure><p>从上面例子可以看出全局作用域和函数作用域的作用范围，即使全局变量在函数内部分配了不同的值，它也只保留在同一函数的边界内，互相并不影响，我们也不会因使用相同的变量名而出错。再来看个例子加深理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">global</span> = <span class="hljs-string">&quot;global scoped&quot;</span>;<br><span class="hljs-keyword">const</span> anotherGlobal = <span class="hljs-string">&quot;also global scoped&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-built_in">global</span> = <span class="hljs-string">&quot;function scoped&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">global</span>); <span class="hljs-comment">// function scoped</span><br>  <span class="hljs-keyword">const</span> scoped = <span class="hljs-string">&quot;also function scoped&quot;</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(scoped); <span class="hljs-comment">// also function scoped</span><br>    <span class="hljs-built_in">console</span>.log(anotherGlobal); <span class="hljs-comment">// also global scoped</span><br>  &#125;<br><br>  inner();<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">global</span>); <span class="hljs-comment">// global scoped</span><br><span class="hljs-built_in">console</span>.log(anotherGlobal); <span class="hljs-comment">// also global scoped</span><br><br>fn();<br>inner(); <span class="hljs-comment">// Uncaught ReferenceError: inner is not defined</span><br></code></pre></td></tr></table></figure><p>在这里我们可以看到 <code>inner()</code> 函数可以访问在其父函数中声明的变量—<code>fn()</code>。每当我们需要函数内部的变量时，引擎将首先在当前函数作用域内查找它。如果它没有当前函数作用域内找到它，它将继续上升，向上一级查找，直到它找到全局作用域内的变量，如果找不到变量，我们将得到一个 ReferenceError。格外注意<strong>函数内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p><p>除了上面所讲的最外层函数外面定义的变量拥有全局作用域，全局作用域还有一种特殊的出现场合：就是<strong>所有末声明直接赋值的变量将自动声明为拥有全局作用域的变量</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>  variable = <span class="hljs-string">&quot;undeclared variable&quot;</span>;<br>  <span class="hljs-keyword">var</span> inVariable = <span class="hljs-string">&quot;inner variable&quot;</span>;<br>&#125;<br><br>fn();<br><span class="hljs-built_in">console</span>.log(variable); <span class="hljs-comment">// undeclared variable</span><br><span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">// Uncaught ReferenceError: inVariable is not defined</span><br></code></pre></td></tr></table></figure><p>全局作用域有个弊端：如果我们写了很多行 JavaScript 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中，这样就会污染全局命名空间，容易引起命名冲突。同时意外的全局变量还会引起内存泄漏，所以在编程时，尽量避免全局变量的使用，以便后期更快地调试。</p><p>还有值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 <code>if</code> 和 <code>switch</code> 条件语句或 <code>for</code> 和 <code>while</code> 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span><br>  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;miqilin&quot;</span>; <span class="hljs-comment">// name 依然在全局作用域中</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// miqilin</span><br></code></pre></td></tr></table></figure><p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致 bug 出现 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>在 ES6 中，我们得到了两个新的变量声明关键字 - <code>let</code>和<code>const</code>。它们和<code>var</code>之间的主要区别在于，使用 ES6 关键字声明的变量是块作用域，这意味着它们仅在它们定义的代码块中可用。块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p><code>let</code> 声明的语法与 <code>var</code> 的语法一致。你基本上可以用 <code>let</code> 来代替 <code>var</code> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li><strong>声明变量不会提升到代码块顶部</strong></li></ul><p><code>let</code>/<code>const</code>创建的变量不会像使用<code>var</code>声明的变量那样被提升到顶部，因此你需要手动将 <code>let</code>/<code>const</code> 声明放置到顶部，以便让变量在整个代码块内部可用。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cosole.log(name); <span class="hljs-comment">// Uncaught ReferenceError: cosole is not defined</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;miqilin&quot;</span>;<br></code></pre></td></tr></table></figure><p>所以确保代码没有引用错误的一种方法是确保只使用<code>let</code>和<code>const</code>进行变量声明。</p><ul><li><strong>禁止重复声明</strong></li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符再进行 <code>let</code> 声明就会抛出错误。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> count = <span class="hljs-number">20</span>; <span class="hljs-comment">// Uncaught SyntaxError: Identifier &#x27;count&#x27; has already been declared</span><br></code></pre></td></tr></table></figure><p>上面例子中<code>count</code> 变量被前后声明了两次：第一次使用 <code>var</code> ，另一次使用 <code>let</code> 。因为 <code>let</code> 不能在同一作用域内重复声明一个已有标识符，此处的 <code>let</code> 声明就会抛出错误。但如果在嵌套的作用域内使用 <code>let</code> 声明一个同名的新变量，则不会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">10</span>;<br><span class="hljs-comment">// 不会抛出错误</span><br><span class="hljs-keyword">if</span> (condition) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">20</span>;<br>  <span class="hljs-comment">// 其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>循环中的绑定块作用域的妙用</strong></li></ul><p>开发者可能最希望实现<code>for</code>循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-built_in">console</span>.log(i);<br><span class="hljs-comment">// ReferenceError: i is not defined</span><br></code></pre></td></tr></table></figure><p>上面代码中，因为用<code>let</code>声明计数器<code>i</code>，只在<code>for</code>循环体内有效，所以在循环体外引用就会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;;<br>&#125;<br>a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p><p>如果换使用 let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  a[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i);<br>  &#125;;<br>&#125;<br>a[<span class="hljs-number">6</span>](); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是 6。你可能会问，如果每一轮循环的变量 i 都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。</p><p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> i = <span class="hljs-string">&quot;abc&quot;</span>;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br><span class="hljs-comment">// abc</span><br></code></pre></td></tr></table></figure><p>上面代码正确运行，输出了 5 次 abc。这表明函数内部的变量 i 与循环变量 i 不在同一个作用域，有各自单独的作用域。</p><h3 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h3><p>上面用一大篇幅来讲解作用域，其实在里面就有涉及到作用域链的知识了。简单的来说，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做<strong>作用域链</strong>。看下面一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(myVar);<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> myVar = <span class="hljs-number">2</span>;<br>  b();<br>&#125;<br><br><span class="hljs-keyword">var</span> myVar = <span class="hljs-number">1</span>;<br>a(); <span class="hljs-comment">// 2</span><br>b(); <span class="hljs-comment">// Uncaught ReferenceError: b is not defined</span><br></code></pre></td></tr></table></figure><p>最后加以执行<code>a()</code>和<code>b()</code>，这时候我们会发现两件事：</p><p>1.执行<code>a()</code>会得到 2 的结果：之所以会有这样的结果，是因为当我们执行<code>function a</code>里面的<code>function b</code>时，因为在<code>function b</code>里面它找不到<code>myVar</code>这个变量，因此它开始往它的外层去搜寻，而这时候它的父级作用域是<code>function a</code>，在<code>function a</code>里面它便找到了<code>myVar = 2</code>，因此它就不再往外部环境 (<code>myVar = 1</code>)去找了，直接返回了 2 这样的结果。</p><p>2.<code>b()</code>会得到<code>b is not defined</code>的结果：之所以<code>b</code>会是<code>not defined</code>（记得是<code>not defined</code>不是<code>undefined</code>哦！)，是因为这时候在最外层的全局上下文（<code>global execution context</code>）中，找不到<code>function b</code>。</p><p>而从<code>b() --&gt; a() --&gt; global execution context</code>这样的链，就称为<strong>作用域链（Scope Chain）</strong>：</p><p><img src="/images/scopechain/2.jpg"></p><p>如果我们把<code>function a</code>里面对于<code>myVar</code>的声明拿掉的话，它才会继续往外层搜寻<code>myVar</code>，直到找到全局作用域中的声明<code>myVar = 1</code>，这时候才会返回 1 的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(myVar);<br>  &#125;<br><br>  <span class="hljs-comment">//var myVar = 2;</span><br>  b();<br>&#125;<br><br><span class="hljs-keyword">var</span> myVar = <span class="hljs-number">1</span>;<br>a(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>如果我们更进一步的把全局作用域中，对于<code>myVar</code>的声明也拿掉，那么现在在全局作用域中也找不到<code>myVar</code>这个变量了，也就是说，在这整个作用域链中都找不到<code>myVar</code>，因此可想而知，最后的结果是<code>not defined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(myVar);<br>  &#125;<br><br>  <span class="hljs-comment">//var myVar = 2;</span><br>  b();<br>&#125;<br><br><span class="hljs-comment">//var myVar = 1;</span><br>a(); <span class="hljs-comment">// Uncaught ReferenceError: myVar is not defined</span><br></code></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一篇&lt;a href=&quot;https://zhuanlan.zhihu.com/p/69142071&quot;&gt;《JavaScript 系列之变量对象》&lt;/a&gt;中，我们已经知道一个执行上下文的数据（函数的形参、函数及变量声明）作为属性储存在变量对象中。&lt;/p&gt;
&lt;p&gt;此外，我们也知</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="Scope" scheme="https://me.miqilin21.cn/tags/Scope/"/>
    
    <category term="Scope Chain" scheme="https://me.miqilin21.cn/tags/Scope-Chain/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之变量对象</title>
    <link href="https://me.miqilin21.cn/2021/05/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://me.miqilin21.cn/2021/05/12/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-05-11T16:00:00.000Z</published>
    <updated>2021-12-16T03:11:31.629Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇<a href="https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/">《JavaScript 系列之执行上下文和执行栈》</a>，通过对变量对象(Variable Object)的介绍对执行上下文有一个更深一步的了解。</p><p>上一篇文章也提到了，一个执行上下文的生命周期可以分为三个阶段：</p><p><img src="/images/scopechain/1.jpg"></p><p>详细了解执行上下文对于初学者来说极为重要，因为其中涉及到了变量对象，作用域链，this 等很多 JavaScript 初学者没完全搞懂，且极为重要的概念，它关系到我们能不能真正理解 JavaScript，真正理解也能更为轻松地胜任后续工作，在后面的文章中我们会一一详细介绍，这里我们先重点了解一下<strong>变量对象</strong>。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象（Variable Object）是一个与执行上下文相关的数据作用域，存储了在上下文中定义的<strong>变量</strong>和<strong>函数声明</strong>，先来看一段代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br>  <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 10</span><br>  <span class="hljs-built_in">console</span>.log(b); <span class="hljs-comment">// function b()&#123;&#125;</span><br>  <span class="hljs-built_in">console</span>.log(c); <span class="hljs-comment">// Uncaught ReferenceError: c is not defined</span><br>&#125;<br><br>foo();<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>foo（）</code>函数的变量对象包含<strong>变量<code>a</code>**和</strong>函数<code>b（）</code>的声明**。这里要注意的一点是，函数表达式并不像函数声明一样包含在变量对象中，在示例中所看到的那样，访问 c（）函数会导致引用错误。因为变量对象是抽象的和特殊的，它不能在代码中访问，但会由 JavaScript 引擎处理。</p><p>上面利用的是函数上下文下的变量对象来说明变量对象储存了什么，但变量对象还存在于全局上下文中，接下来就分别来聊聊全局上下文中和函数上下文中的变量对象吧。</p><h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>以浏览器中为例，全局对象为<code>window</code>。 全局上下文有一个特殊的地方，它的变量对象，就是<code>window</code>全局对象，而这个特殊，在<code>this</code>指向上也同样适用，<code>this</code>也是指向<code>window</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 以浏览器中为例，全局对象为window</span><br><span class="hljs-comment">// 全局上下文创建阶段</span><br><span class="hljs-comment">// VO 为变量对象（Variable Object）的缩写</span><br>windowEC = &#123;<br>  VO: Window,<br>  scopeChain: &#123;&#125;,<br>  <span class="hljs-built_in">this</span>: Window,<br>&#125;;<br></code></pre></td></tr></table></figure><p>除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。</p><h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>在上面已经提到了，变量对象存储了执行上下文中的变量和函数声明，但在函数上下文中，还多了一个<code>arguments(函数参数列表)</code>, 一个伪数组对象。</p><p>这时变量对象的<strong>创建阶段</strong>会包括：</p><ol><li><strong>创建<code>arguments</code>对象</strong>。检查当前上下文中的参数，建立该对象下的属性与属性值。</li><li><strong>检查当前上下文的函数声明，也就是使用 function 关键字声明的函数</strong>。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果变量对象已经存在相同名称的属性，则完全替换这个属性。</li><li><strong>检查当前上下文中的变量声明</strong>（<code>var</code> 声明的变量），默认为 <code>undefined</code>；如果变量名称跟已经声明的形式参数或函数相同，为了防止同名的函数被修改为<code>undefined</code>，则会直接跳过变量声明，原属性值不会被修改。</li></ol><p><img src="/images/variableobject/1.jpg"></p><p>对于第 3 点中的“跳过”一词想必大家会有一丝疑问？底下例子中既然按照上面的规则，变量声明的<code>foo</code>遇到函数声明的<code>foo</code>会跳过，可是为什么最后<code>foo</code>的输出结果仍然是被覆盖了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I am function foo&quot;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>;<br><br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>理由其实很简单，因为上面的三条规则仅仅适用于变量对象的<strong>创建过程</strong>，也就是执行上下文的创建过程。而<code>foo = 10</code>是在执行上下文的<strong>执行过程</strong>中运行的，输出结果自然会是 10。对比下例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// ƒ foo() &#123; console.log(&#x27;I am function foo&#x27;) &#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I am function foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>为啥又是不一样的结果呢？其实它的执行顺序为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 首先将所有函数声明放入变量对象中，函数声明变量提升</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I am function foo&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 其次将所有变量声明放入变量对象中，但是因为foo已经存在同名函数，因此此时会跳过变量声明默认undefined的赋值</span><br><span class="hljs-comment">// var foo = undefined;</span><br><br><span class="hljs-comment">// 然后开始执行阶段代码的执行</span><br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// ƒ foo() &#123; console.log(&#x27;I am function foo&#x27;) &#125;</span><br><br><span class="hljs-comment">// 在执行上下文的执行过程中运行</span><br>foo = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>根据上面的规则，理解变量提升就变得十分简单了，我们也可以看出，**<code>function</code>声明会比<code>var</code>声明优先级更高一点**。为了帮助大家更好的理解变量对象，我们再结合一个简单的例子来进行探讨。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>  <span class="hljs-built_in">console</span>.log(foo());<br><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br>test();<br><br><span class="hljs-comment">/* 结果为：</span><br><span class="hljs-comment">undefined</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>根据上述的规则，理解变量提升后可以将执行顺序理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">var</span> a;<br>  <span class="hljs-built_in">console</span>.log(a);<br>  <span class="hljs-built_in">console</span>.log(foo());<br>  a = <span class="hljs-number">1</span>;<br>&#125;<br><br>test();<br></code></pre></td></tr></table></figure><p>这样是不是一目了然了呢？</p><p>当然还需要注意的是，函数未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象（VO）转变为了活动对象（AO），然后开始进行执行阶段的操作。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>当前进入执行阶段，变量对象（VO）激活成活动对象（AO），里面的属性都能被访问了，函数会顺序执行代码，改变变量对象的属性值，此阶段的执行上下文代码会分成两个阶段进行处理：</p><ol><li>进入执行上下文</li><li>执行代码</li></ol><h4 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h4><p>当进入执行上下文时，这时候还没有执行代码。让我们看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> c = <span class="hljs-number">10</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  <span class="hljs-keyword">var</span> e = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_e</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>&#123;&#125;);<br>&#125;<br><br>foo(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>当进入带有参数 10 的<code>foo</code>函数上下文时，AO 表现为如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">AO = &#123;<br>    <span class="hljs-built_in">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-number">1</span>: <span class="hljs-literal">undefined</span>,<br>        length: <span class="hljs-number">1</span><br>    &#125;<br>    a: <span class="hljs-number">10</span>,<br>    b: <span class="hljs-literal">undefined</span>,<br>    c: <span class="hljs-literal">undefined</span>,<br>    d: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">function</span> <span class="hljs-attr">reference</span> <span class="hljs-attr">to</span> <span class="hljs-attr">d</span>&gt;</span>,</span><br><span class="xml">    e: undefined,</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p><code>x</code> 是函数表达式，所以不在变量对象当中，<code>e</code> 变量引用的值也是函数表达式，所以变量 <code>e</code> 本身是声明，所以在变量对象当中。</p><h4 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h4><p>这个阶段会按顺序执行代码，修改变量对象的属性值，紧接上面的例子，执行完成后 AO 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">AO = &#123;<br>    <span class="hljs-built_in">arguments</span>: &#123;<br>        <span class="hljs-number">0</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-number">1</span>: <span class="hljs-literal">undefined</span>,<br>        length: <span class="hljs-number">1</span><br>    &#125;<br>    a: <span class="hljs-number">10</span>,<br>    b: <span class="hljs-literal">undefined</span>,<br>    c: <span class="hljs-number">10</span>,<br>    d: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">reference</span> <span class="hljs-attr">to</span> <span class="hljs-attr">function</span> <span class="hljs-attr">declaration</span> <span class="hljs-attr">d</span>&gt;</span>,</span><br>    e: &lt;reference to Function expression to _e&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里变量对象的创建过程就介绍完了，让我们简短地总结一下：</p><ol><li>全局上下文的变量对象初始化是全局对象</li><li>函数上下文的变量对象初始化只包括 <code>Arguments</code> 对象</li><li>在进入执行上下文时会依次给变量对象<strong>添加形参</strong>、<strong>函数声明</strong>、<strong>变量声明</strong>等初始的属性值</li><li>函数未进入执行阶段之前，变量对象中的属性都不能访问</li><li>在执行代码阶段，会再次修改变量对象的属性值，并赋予该有的属性值</li></ol><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JavaScript 编程的时候总规避不了声明变量和函数，但是解释器是如何并且在什么地方去查找这些变量和函数呢？接下来，再延续上一篇&lt;a href=&quot;https://luozongmin.com/2019/06/13/JavaScript%E7%B3%BB%E5%88%97</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="变量对象" scheme="https://me.miqilin21.cn/tags/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript系列之执行上下文和执行栈</title>
    <link href="https://me.miqilin21.cn/2021/05/04/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
    <id>https://me.miqilin21.cn/2021/05/04/JavaScript%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</id>
    <published>2021-05-03T16:00:00.000Z</published>
    <updated>2021-12-16T03:12:46.810Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想成为一名优秀的 JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。</p><p>执行上下文和执行栈是 JavaScript 的难点之一，所以本人尽量用通俗易懂的方式来阐述这些概念。</p><h3 id="执行上下文（Execution-Context）"><a href="#执行上下文（Execution-Context）" class="headerlink" title="执行上下文（Execution Context）"></a>执行上下文（Execution Context）</h3><p>当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。执行上下文（可执行代码段）总共有三种类型：</p><ul><li><strong>全局执行上下文（全局代码）</strong>：不在任何函数中的代码都位于全局执行上下文中，只有一个，浏览器中的全局对象就是 <code>window</code> 对象，<code>this</code> 指向这个全局对象。</li><li><strong>函数执行上下文（函数体）</strong>：只有调用函数时，才会为该函数创建一个新的执行上下文，可以存在无数个，每当一个新的执行上下文被创-建，它都会按照特定的顺序执行一系列步骤。</li><li><strong><code>Eval</code> 函数执行上下文（eval 代码）</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</li></ul><p>执行上下文又包括三个生命周期阶段：<strong>创建阶段 → 执行阶段 → 回收阶段</strong>，本文重点介绍创建阶段。</p><p><strong>1.创建阶段</strong></p><p>当函数被调用，但未执行任何其内部代码之前，会做以下三件事：</p><ul><li>**创建变量对象(Variable object，VO)**：首先初始化函数的参数<code>arguments</code>，提升函数声明和变量声明。后文会详细说明。</li><li><strong>创建作用域链（Scope Chain</strong>：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。后文会详细说明。</li><li><strong>确定 this 指向</strong>：包括多种情况，后文会详细说明。</li></ul><p>在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来。变量先暂时赋值为<code>undefined</code>，函数则先声明好可使用。这一步做完了，然后再开始正式执行程序。</p><p>另外，一个函数在被执行之前，也会创建一个函数执行上下文环境，跟全局上下文差不多，不过函数执行上下文中会多出<code>this</code> 、 <code>arguments</code>和函数的参数。</p><p><strong>2.执行阶段</strong></p><p>进入执行上下文、执行代码</p><p><strong>3.回收阶段</strong></p><p>执行完毕后执行上下文出栈并等待被垃圾回收</p><p><img src="/images/scopechain/1.jpg"></p><h3 id="执行上下文栈（Execution-Context-Stack）"><a href="#执行上下文栈（Execution-Context-Stack）" class="headerlink" title="执行上下文栈（Execution Context Stack）"></a>执行上下文栈（Execution Context Stack）</h3><p>假如我们写的函数多了，每次调用函数时都创建一个新的执行上下文，如何管理创建的那么多执行上下文呢？</p><p>所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文，具有 LIFO（后进先出）的栈结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行 JS 代码时，会创建一个<strong>全局</strong>执行上下文并 Push 到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个<strong>新的函数</strong>执行上下文并 Push 到当前执行栈的顶部，浏览器的 JS 执行引擎总是访问栈顶的执行上下文。</p><p>根据执行栈 LIFO 规则，当栈顶函数运行完成后，其对应的<strong>函数</strong>执行上下文将会从执行栈中 Pop 出，上下文控制权将移到当前执行栈的<strong>下一个</strong>执行上下文，最终移回到<strong>全局</strong>执行上下文，全局上下文只有唯一的一个，它在浏览器关闭时 Pop 出。</p><p>看到目前为止，是否觉得这两个概念还是有点晦涩难懂呢？那…接下来通过几小段代码和图解来详细介绍并理解吧。</p><h3 id="执行上下文是如何执行的呢？"><a href="#执行上下文是如何执行的呢？" class="headerlink" title="执行上下文是如何执行的呢？"></a>执行上下文是如何执行的呢？</h3><p>让我们先来看一下这段简单代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  b();<br>&#125;<br>a();<br></code></pre></td></tr></table></figure><p>这段代码背后执行的逻辑是这样的：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，这时候会一并建立<code>this</code>、<code>global object</code> (<code>window</code>)，在函数开始执行的过程中，<code>function a</code>和<code>b</code>由于 JS 提升机制的缘故会先被建立在内存中，接着才会开始逐行执行函数。</p><p><img src="/images/context/1.jpg"></p><p>接着，代码会执行到<code>a( )</code>这个部分，这时候，会建立<code>a</code>的执行上下文（execution context），并且被放置到执行栈（execution stack）中。在这个 execution stack 中，最上面的 execution context 会是正在被执行的<code>a( )</code>。如下图：</p><p><img src="/images/context/2.jpg"></p><p><code>function a</code> 的 execution context 建立后，便会开始执行<code>function a</code>中的内容。由于在<code>function a( )</code> 里面有去执行<code>function b</code> ，因此，在这个 execution stack 中，接下来最上面会变成<code>function b</code> 的 execution context。如下图：</p><p><img src="/images/context/3.jpg"></p><p>当<code>function b</code> 执行完之后，会从 execution stack 中离开，继续逐行执行<code>function a</code>。当<code>function a</code> 执行完之后，一样会从 execution stack 中抽离，再回到 Global Execution Context 逐行执行。如下图：</p><p><img src="/images/context/4.jpg"></p><h3 id="不同执行上下文中的变量是不同的"><a href="#不同执行上下文中的变量是不同的" class="headerlink" title="不同执行上下文中的变量是不同的"></a>不同执行上下文中的变量是不同的</h3><p>在了解了一般的函数其运作背后的逻辑后，让我们来看一下这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> myVar;<br>  <span class="hljs-built_in">console</span>.log(myVar);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> myVar = <span class="hljs-number">2</span>;<br>  b();<br>  <span class="hljs-built_in">console</span>.log(myVar);<br>&#125;<br><br><span class="hljs-keyword">var</span> myVar = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(myVar);<br>a();<br></code></pre></td></tr></table></figure><p>你可以想像，如果我们在不同的 execution context 中去把<code>myVar</code>这个变量打出来，会得到什么结果呢？结果如下：</p><p><img src="/images/context/5.jpg"></p><p>我们分别得到了 1、<code>undefined</code>和 2。为什么会这样呢？</p><p>让我们来看看这段代码背后执行的逻辑：</p><p>首先，全局执行上下文（Global Execution Context）会被建立，由于变量提升的缘故，<code>myVar</code>、<code>function a</code>和<code>b</code>都会被建立并储存在内存中，接着便开始逐行执行函数。一开始会碰到<code>var myVar = 1</code>所以，最外层的<code>myVar</code>便被给值为 1，接着执行到了<code>console.log(myVar)</code>，这是在 global execution context 执行的，于是得到了第一个 1 的结果：</p><p><img src="/images/context/6.jpg"></p><p>然后执行到了<code>a ( )</code>，于是建立了<code>a</code>的 execution context，这时候由于逐行执行的关系，会先执行到<code>var myVar = 2</code>，但因为这是在 function a 的 execution context 中，所以并不会影响到 global execution context 的<code>myVar</code>：</p><p><img src="/images/context/7.jpg"></p><p>在执行完<code>function a</code>中的<code>var myVar = 2</code>后，继续逐行执行，于是执行到了<code>b ( )</code>，这时候，<code>function b</code>的 execution function 便被建立，而且会先去执行<code>function b</code>里面的内容：</p><p><img src="/images/context/8.jpg"></p><p><code>function b</code>的 execution function 建立后，会开始逐行执行<code>function b</code>里面的内容，于是读到了<code>var myVar</code>;，这时候在<code>function b</code>这个 execution context 中的<code>myVar</code>变量被建立，但是还没被赋值，所以会是<code>undefined</code>。和上面提到的一样，由于这个<code>myVar</code>是在<code>function b</code>中的 execution context 所建立，所以并不会影响到其他 execution context 的<code>myVar</code>，这时候执行到了<code>function b</code>的 execution context 中的<code>console.log(myVar)</code>，于是得到了第二个看到的<code>undefined</code>：</p><p><img src="/images/context/9.jpg"></p><p>最后，<code>function b</code>执行完之后，会从 execution stack 中离开，继续回到<code>function a</code>中的<code>b( )</code>后逐行执行，也就是<code>console.log(myVar)</code>，这时候是在 function a 的 execution context 加以执行的，因此也就得到了结果中看到的第三个 2 了。</p><p>最后由于<code>b ( )</code> 后面已经没有内容，<code>function a</code>执行完毕，这时候，<code>function a</code>也会从 execution stack 中抽离。</p><p><img src="/images/context/10.jpg"></p><p>最后回到 Global Execution Context，如果函数中的<code>a( )</code>后面还有内容的话，会继续进行逐行执行。</p><p>由上面的例子，我们可以知道，我们是在不同的 execution context 中分别去声明变量<code>myVar</code>的，<strong>因此在不同的 execution context，变量彼此之间不会影响</strong>，所以虽然这三个变量都叫做<code>myVar</code>，但其实是三个不同的变量。</p><p>由于我们是在不同的 execution context 中去声明变量，所以这其实是位于三个不同 execution context 中的变量，所以即使我们是在执行完<code>a( )</code>后再去调用一次<code>myVar</code>，一样会得到” 1”的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> myVar;<br>  <span class="hljs-built_in">console</span>.log(myVar);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> myVar = <span class="hljs-number">2</span>;<br>  b();<br>  <span class="hljs-built_in">console</span>.log(myVar);<br>&#125;<br><br><span class="hljs-keyword">var</span> myVar = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(myVar);<br>a();<br><span class="hljs-built_in">console</span>.log(myVar); <span class="hljs-comment">// 一样会得到&quot;1&quot;</span><br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>最后需要注意的是，如果是在<code>function</code>里面直接使用<code>myVar</code>这个变量，而没有通过<code>var</code>重新声明它的话，就会得到不同的结果！因为在函数作用域内加 <code>var</code> 定义的变量是局部变量，不加 <code>var</code> 定义的就成了全局变量。在未声明新的变量的情况下，在该 execution context 中 JavaScript 引擎找不到这个变量，它就会往它的外层去寻找，最后会得到，1 ,2 ,2 ,2 的结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;<br>  myVar;<br>  <span class="hljs-built_in">console</span>.log(myVar);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  myVar = <span class="hljs-number">2</span>;<br>  b();<br>  <span class="hljs-built_in">console</span>.log(myVar);<br>&#125;<br><br><span class="hljs-keyword">var</span> myVar = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(myVar);<br>a();<br><span class="hljs-built_in">console</span>.log(myVar);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印出</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你想成为一名优秀的 JavaScript 开发者，那你就必须了解 JavaScript 程序内部的执行机制。而执行上下文和执行栈是其关键概念之一， 理解执行上下文和执行栈同样有助于理解其他的 JavaScript 概念如提升机制、作用域和闭包等。&lt;/p&gt;
&lt;p&gt;执行上下</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="Execution Context" scheme="https://me.miqilin21.cn/tags/Execution-Context/"/>
    
    <category term="Execution Context Stack" scheme="https://me.miqilin21.cn/tags/Execution-Context-Stack/"/>
    
  </entry>
  
  <entry>
    <title>谈谈JavaScript中的函数构造式和prototype的建立</title>
    <link href="https://me.miqilin21.cn/2021/04/24/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/"/>
    <id>https://me.miqilin21.cn/2021/04/24/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E5%BC%8F%E5%92%8Cprototype%E7%9A%84%E5%BB%BA%E7%AB%8B/</id>
    <published>2021-04-23T16:00:00.000Z</published>
    <updated>2021-12-16T03:18:44.474Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%94%AE%E5%AD%97/">《谈谈 JavaScript 中的 function constructor 和 new 关键字》</a>这篇文章中我们说明了如何通过函数构造式（function constructor）搭配关键字 new 来建立对象，但其实这样只讲了一半，在这篇我们会补齐另一半，说明 function constructor 如何用来设定该对象的原型（prototype）。</p><p>在 JavaScript 中的函数也是一种对象，其中包含一些属性像是该函数的名称（<code>Name</code>）和该函数的内容（<code>Code</code>），但其实<code>function</code>这里面还有一个属性，这个属性就是<code>prototype</code>，这个属性会以空对象的型式呈现。</p><p>除非你是把<code>function</code>当做<code>function constructor</code>来使用，否则这个属性就没有特别的用途；但如果你是把它当做<code>function constructor</code>，通过<code>new</code>这个关键字来执行这个<code>function</code>的话，它就有特别的意义了。</p><p><img src="/images/constructor/1.jpg"></p><p>要进入这个<code>function</code>的<code>prototype</code>属性只要直接通过 <code>.prototype</code> 就可以了。</p><p>然而，有一点很容易令人困惑的地方，我们会以为如果我使用 <code>.prototype</code> 时，就可以直接进入该函数的原型，但实际上并不是这样的！</p><p>**函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个<code>function constructor</code>所建立出来的对象的<code>prototype</code>**，听起来有点混乱吧…没关系，让我们来看一些代码来帮助我们理解这一概念。</p><h3 id="说明函数中的-prototype-属性"><a href="#说明函数中的-prototype-属性" class="headerlink" title="说明函数中的 prototype 属性"></a>说明函数中的 prototype 属性</h3><p><strong>1.function 中的 prototype 属性一开始是空对象</strong></p><p>我们先执行上篇文章最后所写的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.firstName = firstName;<br>  <span class="hljs-built_in">this</span>.lastName = lastName;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;chou&quot;</span>);<br><span class="hljs-built_in">console</span>.log(person1);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-string">&quot;chou&quot;</span>);<br><span class="hljs-built_in">console</span>.log(person2);<br></code></pre></td></tr></table></figure><p>到 Google Chrome 的 console 视窗中，我们输入 <code>Person.prototype</code>得到的结果会得到一个空对象，如下图：</p><p><img src="/images/constructor/2.jpg"></p><p><strong>2.通过 function constructor 所建立的对象会继承该 function 中 prototype 的内容</strong></p><p>接着，让我们在<code>Person.prototype</code>里面增加一个<code>getFullName</code>的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.firstName = firstName;<br>  <span class="hljs-built_in">this</span>.lastName = lastName;<br>&#125;<br><br>Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;chou&quot;</span>);<br><span class="hljs-built_in">console</span>.log(person1);<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jane&quot;</span>, <span class="hljs-string">&quot;chou&quot;</span>);<br><span class="hljs-built_in">console</span>.log(person2);<br></code></pre></td></tr></table></figure><p>在上面代码的第 6 - 8 行中，我们为<code>Person.prototype</code>添加了一个函数，所以当我们在 Google Chrome 的 console 视窗中调用<code>Person.prototype</code>时，会多了这个函数在内：</p><p><img src="/images/constructor/3.jpg"></p><p>刚刚，我们有提到很重要的一句话，「**函数当中<code>prototype</code>这个属性并不是这个函数的<code>prototype</code>，它指的是所有通过这个 function constructor 所建立出来的对象的<code>prototype</code>**」。</p><p>这句话的意思其实是说<code>Person.prototype</code>并不是<code>Person.__proto__</code>，但是所有通过<code>Person</code>这个<code>function constructor</code>所建立的对象，在该实例对象的<code>__proto__</code>中，会包含有<code>Person.prototype</code>的内容。</p><p>也就是说，当我们使用<code>new</code>这个运算符来执行<code>function constructor</code>时，它会先建立一个空对象，同时将该构造函数中<code>prototype</code>这个属性的内容（<code>Person.prototype</code>），设置到该实例对象的<code>prototype</code>中，即 <code>person1.__proto__ === Person.prototype</code>的结果为<code>true</code>。</p><p>因此，当我们在 Google Chrome 的 console 中输入<code>person1.__proto__</code>时，我们就可以看到刚刚在<code>Person.prototype</code>所建立的函数<code>getFullName</code>已经继承在里面了：</p><p><img src="/images/constructor/4.jpg"></p><h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>由于<code>Person.prototype</code>中的方法已经被继承到由<code>Person</code>这个<code>function constructor</code>所建立的实例对象<code>person1</code>中，所以这时侯，我们就可以顺利的使用 <code>person1.getFullName</code> 这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.firstName = firstName;<br>  <span class="hljs-built_in">this</span>.lastName = lastName;<br>&#125;<br><br>Person.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;chou&quot;</span>);<br><span class="hljs-built_in">console</span>.log(person1);<br><span class="hljs-built_in">console</span>.log(person1.getFullName());<br></code></pre></td></tr></table></figure><p>可以正确的执行<code>getFullName</code>这个函数并得到如下的结果：</p><p><img src="/images/constructor/5.png"></p><h3 id="通过-function-constructor-与-Prototype-的实用处"><a href="#通过-function-constructor-与-Prototype-的实用处" class="headerlink" title="通过 function constructor 与 Prototype 的实用处"></a>通过 function constructor 与 Prototype 的实用处</h3><p>通过这样的方法，我们可以让所有根据这个函数构造器（<code>function constructor</code>）所建立的对象都包含有某些我们想要使用的方法。如果我们有 1000 个对象是根据这个函数构造器所建立的，那么我们只需要使用 <code>.prototype</code>这样的方法，就可以让这 1000 个物件都可以使用到我们想要执行的某个<code>method</code>，这样减少了代码的复用。</p><p>有的人可能会好奇问，为什么我们不把<code>getFullName</code>这个方法直接写在函数构造式当中呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.firstName = firstName;<br>  <span class="hljs-built_in">this</span>.lastName = lastName;<br>  <span class="hljs-built_in">this</span>.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">this</span>.lastName;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Person . prototype . getFullName  =  function ( )  &#123; </span><br><span class="hljs-comment">  return  this . firstName +  &#x27; &#x27;  +  this . lastName ; </span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><blockquote><p>注意！我们不该把方法放在<code>function constructor</code> 中。</p></blockquote><p>把方法放在函数构造式中这么做虽然仍然可以正确执行并得到结果，但是这么做会有个问题，如果我们是把这个方法直接写在函数构造式中，那么每一个对象都会包含有这个方法，如果我们有 1000 个对象根据这个函数构造式所建立，那么这 1000 个对象都会包含这个方法在内，如此将会占据相当多的内存；但如果是建立在<code>prototype</code> 中，我们只会有一个这样的方法。</p><p>所以，为了性能上的考量，通常会把方法（<code>method</code>）放在构造函数的<code>prototype</code> 中，因为它们可以是通用的；把属性（<code>property</code>）放在构造函数当中，因为每一个对象可能都会有不同的属性内容，如此将能有效减少内存的问题。</p><p>最后，如果感觉当前缺少你要用的方法，可以自己通过这一方法去创建。</p><p>例如在 json2.js 源码中，为<code>Date</code>、<code>String</code>、<code>Number</code>、<code>Boolean</code>方法添加一个<code>toJSON</code>的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Date</span>.prototype.toJSON !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>  <span class="hljs-built_in">Date</span>.prototype.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isFinite</span>(<span class="hljs-built_in">this</span>.valueOf())<br>      ? <span class="hljs-built_in">this</span>.getUTCFullYear() +<br>          <span class="hljs-string">&quot;-&quot;</span> +<br>          f(<span class="hljs-built_in">this</span>.getUTCMonth() + <span class="hljs-number">1</span>) +<br>          <span class="hljs-string">&quot;-&quot;</span> +<br>          f(<span class="hljs-built_in">this</span>.getUTCDate()) +<br>          <span class="hljs-string">&quot;T&quot;</span> +<br>          f(<span class="hljs-built_in">this</span>.getUTCHours()) +<br>          <span class="hljs-string">&quot;:&quot;</span> +<br>          f(<span class="hljs-built_in">this</span>.getUTCMinutes()) +<br>          <span class="hljs-string">&quot;:&quot;</span> +<br>          f(<span class="hljs-built_in">this</span>.getUTCSeconds()) +<br>          <span class="hljs-string">&quot;Z&quot;</span><br>      : <span class="hljs-literal">null</span>;<br>  &#125;;<br><br>  <span class="hljs-built_in">String</span>.prototype.toJSON = <span class="hljs-built_in">Number</span>.prototype.toJSON = <span class="hljs-built_in">Boolean</span>.prototype.toJSON = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    key</span></span><br><span class="hljs-function"><span class="hljs-params">  </span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf();<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你要添加内置方法的原型属性，最好做一步判断，如果该属性不存在，则添加。如果本来就存在，就没必要再添加了。</p><p><strong>如果觉得文章对你有些许帮助，欢迎在<a href="https://github.com/miqilin21/miqilin21.github.io">我的 GitHub 博客</a>点赞和关注，感激不尽！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://luozongmin.com/2019/06/11/%E8%B0%88%E8%B0%88JavaScript%E4%B8%AD%E7%9A%84function%20constructor%E5%92%8Cnew%E5%85%B3%E9%</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://me.miqilin21.cn/tags/JavaScript/"/>
    
    <category term="constructor" scheme="https://me.miqilin21.cn/tags/constructor/"/>
    
    <category term="prototype" scheme="https://me.miqilin21.cn/tags/prototype/"/>
    
  </entry>
  
</feed>
